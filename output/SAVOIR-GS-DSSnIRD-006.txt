The Mass Memory System shall provide one to several storage media in order to support the storage of data received through its physical interface(s).[END]
A storage media shall be made either of volatile or non-volatile memory.[END]
The MMS shall provide data retention for at least <MM Retention Time> days from hardware unit manufacturing to <Satellite Launch Time> + <Planned Mission Time> for all storage media with non-volatile memory.[END]
The capacity of storage media shall be expressed at End Of Life.[END]
The content of the non-volatile memory of storage media shall be maintained even in case of a power cycle of the spacecraft or the storage media(s).[END]
The content of the volatile memory of storage media shall be maintained except in case of a power cycle of the spacecraft or the storage media(s).[END]
The content of the volatile memory of storage media shall be protected against the radiations.[END]
The MMS shall support configuration changes of storage media.[END]
All the memory of MMS storage media shall be accessible for reading from Ground.[END]
All the writeable memory of MMS storage media shall be accessible for modification by Ground.[END]
The MMS shall rely on the time provided by the On-Board Time for its time related operations.[END]
The MMS time base shall be correlated with th e On-Board Time with an accuracy of <MM On-Board Time allowed time difference>.[END]
The MMS shall support the unique identification of User Entities.[END]
The MMS shall implement a layered architecture.[END]
The MMS shall implement at least one interface for Command & Control.[END]
Any MMS Command & Control interface shall support both RX and TX.[END]
The MMS shall implement zero or more in terface for direct data acquisition.[END]
Any MMS interface used for direct data acquisition shall support at least RX, and optionally TX.[END]
Each MMS input interface used for direct data acquisition (i.e. excluding C&C interface) shall be classified among three types, defining the data handling level (raw, data link protocol, packet) and implicitly the supported mapping(s):xRAW – received data is handled as a data flow without interpretation,xLINK_PROTOCOL – received data is handled at the level of entity exchanged on the link (i.e. SpaceWire packet, 1553 Frame, etc.). Received data flow is interpreted to identify the address, and only Protocol Address mapping is supported,xPACKET – received data is handled at the level of Consultative Committee for Space Data Systems packet. Received data flow is interpreted and reassembled into Packets (potentially Packet Utilisation Standard packets). Packet Application Identifier and Custom Packet Field mappings are supported for both standard and Packet Utilisation Standardpackets, whereas Packet Service and Packet Service & Subservice mappings are supported only for Packet Utilisation Standard packets.[END]
Each MMS input interface used for direct data acquisition shall discard data that are not mapped to any of the Data Management System (File or Packet).[END]
The MMS shall support Packet Utilisation Standard-C services 1 (request verification).[END]
The MMS shall support Packet Utilisation Standard-C services 2 (device access).[END]
The MMS shall support Packet Utilisation Standard-C services 3 (housekeeping).[END]
The MMS shall support Packet Utilisation Standard-C serv ices 5 (event reporting).[END]
The MMS shall support Packet Utilisation Standard-C services 6 (memory management).[END]
The MMS shall support Packet Utilisation Standard-C services 15 (on-board storage and retrieval).[END]
The MMS shall support Packet Utilisation Standard-C services 17 (test).[END]
The MMS can support Packet Utilisation Standard-C services 20 (parameter management).[END]
The MMS shall support Packet Utilisation Standard-C services 23 (file management).[END]
The MMS shall support a Packet Utilisation Standard-C specific service giving access to MMS services.[END]
The MMS shall support generic Remote File Ma nagement Protocol for remote access to the services provided by the File Management System interface.[END]
The MMS shall support generic Re mote Block Management Prot ocol for remote access to the services provided by the File Management System interface.[END]
Wire standardWhen using SpaceWire links the MMS shall comply with European Cooperation for Space Standardization-E-ST-50-12C SpaceWire -Links, nodes, routers and networks.[END]
Wire protocol identification standardWhen using SpaceWire links the MMS shall comply with European Cooperation for Space Standardization-E-ST-50-51C SpaceWire protocol identification.[END]
Wire Remote Memory Access Protocol standardWhen using SpaceWire for remote memory access, the MMS shall comply with European Cooperation for Space Standardization-E-ST-50-52C SpaceWire - Remote memory access protocol.[END]
Wire CPTP standardWhen using SpaceWire for Consultative Committee for Space Data Systems packet transfer the MMS shall comply with European Cooperation for Space Standardization-E-ST-50-53C SpaceWire - Consultative Committee for Space Data Systems packet transfer protocol.[END]
When using the Mil-STD-1553 data bus, the MMS shall comply with European Cooperation for Space Standardization-E-ST-50-13C Interface and communication protocol for MIL-STD-1553B data bus on-board spacecraft.[END]
When using the CAN data bus, the MM shall comply with European Cooperation for Space Standardization-E-ST-50-15C.[END]
The MMS shall be able to manage one or more Storage Media.[END]
The MMS shall support the organisa tion of the overall data st orage area provided by the Storage Media into one or several Stores.[END]
Accesses to a Store at Block Allocable Unit level shall be managed by a Block Access System.[END]
The Block Allocable Unit located in a remote Storage Media (i.e. not directly embedded within the MMS)shall be accessed through a Remote Block Ac cess Protocol.[END]
The MMS shall support one to several Block Access Systems.[END]
A Store shall be characterized by at least:xa unique identifier among all the Stores,xthe block access unit (Block Allocable Unit) size,xthe total storage capacity (in number of Block Allocable Unit),xthe collection of Block Allocable Unit (its structure allowing to identify and navigate between the Block Allocable Units, over one or several storage media),xthe access capability (Read-only or R/W),xthe permission to access it at User Entity level.[END]
The MMS shall support one to several Data Ma nagement Systems to manage the content of the Stores.[END]
The MMS shall support one File Management Systems (File Management System) providing high-level services for data storage into Stores.[END]
The File Management System shall be independent from the low-level storage technology and internal File System organization.[END]
The File Management System shall comply with the file access and file management services required by the on-board software for supporting implementations of Packet Utilisation Standard service 23.[END]
The File Management System shall comply with the file access and file management services required by the on-board software for supporting implementations of Consultative Committee for Space Data Systems File Delivery Protocol.[END]
The File Management System shall determine how to access a File Store from its identifier:xThrough the local File System associated to the Store,xThrough a Remote File Management Prot ocol in the case of a remote Store.[END]
The File Management System shall support one or more File Syst ems to manage data storage within Stores, possibly implementing different logical organizations.[END]
The File System shall identify its characteristics including:- data organisation scheme (e.g. contiguous, block, i-node),- maximum number of entries (files an d directories) per directory (root and subdirectories),- maximum depth of the directory tree (0 = flat system),- supported attributes per entry, e.g. "hidden" attribute, permission attributes,- maximum number of attributes per entry,- the capability to lock files,- the type of checksums supported,- referencing system (string, numerical value) and in case of string referencing system:• directory separator (e.g. "/" or "\"),• metacharacters (e.g. "*" and "?"),• maximum number of characters per entry identifier and syntax, e.g. 8.3, 128 characters.[END]
The File Management System shall support organizing files into directories.[END]
The File Management System shall support a directory depth of <DIRECTORY_MAX_DEPTH>.[END]
A Store root directory sha ll always exist in a File Store managed by a File Management System.[END]
A directory shall be uniquely identified by its path, consisting in the gathering of:• The identifier of the File Store in which it is contained,• The tree of parent directories identifiers up to the Store root directory,• Its own unique identifier within its parent directory.[END]
The MMS shall support zero or more Packet Management Sy stem (Packet Management Service) providing high-level services for Consultative Committee for Space Data Systems Packet storage into Packet Stores.[END]
The Packet Management Service shall be independent from the low-level storage technology and logical Packets organization.[END]
The Packet Management Service shall comply with the packet management services required by the on-board software for supporting implementations of Packet Utilisation Standard service 15.[END]
A Block Allocable Unit shall be composed by the list of Smallest Allocable Units being part of the Block Allocable Unit.[END]
A Block Allocable Unit shall be uniquely identified within the MMS.[END]
A list of Block Allocable Units shall identify all the Block Allocable Units that are part of the list.[END]
A Block Access System shall support read access to all Block Allocable Units.[END]
A Block Access System shall support write access to Block Allocable Units not identified as read-only.[END]
A Block Access System shall support erasing the content of Block Allocable Units not identified as read-only.[END]
A Block Access System shall support disabling Block Allocable Units.[END]
A Block Access System shall support enabling Block Allocable Units.[END]
A Block Access System shall support locking Block Allocable Units by a particular User Entity in:-Exclusive_Read_Only: The User Entity can only Read the Block Allocable Units. Other User Entities cannot read or write the Block Allocable Unit.-Read_Only: All User Entities can only read from the Block Allocable Unit.-Exclusive_Access: The User Entity can read from and write to the Block Allocable Unit. Other User Entities cannot read from or write to the Block Allocable Unit;-Single_Writer: The User Entity can read from and write to the Block Allocable Unit. Other User Entities can only read from the Block Allocable Unit.[END]
A Block Access System shall support unlocking Block Allocable Units by a particular User Entity.[END]
The Block Allocable Unit Identifier parameter shall uniquely identify a Block Allocable Unit.[END]
The Block Allocable Unit List parameter shall be made of a list of Block Allocable Units.[END]
The Block Allocable Unit Erase Pattern parameter shall define the pattern to be used when erasing a Block Allocable Unit.[END]
The Block Allocable Unit Lock Type parameter shall specify a lock action on a Block Allocable Unit. Possible values are:-Exclusive_Read_Only : The lock-owner can only read from the Block Allocable Unit. Other user entities cannot read from or write to the Block Allocable Unit;-Read_Only : The lock-owner can only read from the Block Allocable Unit. Other user entities can only read from the Block Allocable Unit (i.e. everyone can read);-Exclusive_Access : The lock-owner can read from and write to the Block Allocable Unit. Other user entities cannot read from or write to the Block Allocable Unit;-Single_Writer : The lock-owner can read from and write to the Block Allocable Unit. Other user entities can only read from the Block Allocable Unit.[END]
The Block Allocable Unit Transaction Identifier shall be a value, assigned by the invoking User Entity, which is subsequently used to associate indication primitives with the causal request primitives.[END]
The Block Allocable Unit List Content shall be the data contained in all Block Allocable Units from a Block Allocable Unit list.[END]
The Block Allocable Unit Result Metadata parameter shall be used to provide information generated by the Block Access System provider to the User Entity regarding result of the execution of a request.[END]
The Bloc Access System shall provide the following primitives:-READ_Block Allocable Unit.request, READ_Block Allocable Unit.indication-WRITE_Block Allocable Unit.request, WRITE_Block Allocable Unit.indication-ERASE_Block Allocable Unit.request, ERASE_Block Allocable Unit.indication-DISABLE_Block Allocable Unit.request, DISABLE_Block Allocable Unit.indication-ENABLE_Block Allocable Unit.request, EN ABLE_Block Allocable Unit.indication-LOCK_Block Allocable Unit.request, LOCK_Block Allocable Unit.indication-UNLOCK_Block Allocable Unit.request, UN LOCK_Block Allocable Unit.indication[END]
The READ_Block Allocable Unit.request primitive shall be passed to the Block Access System provider to request in-order readin g of a list of Block Allocable Units.[END]
The READ_Block Allocable Unit.request primitive shall use the following semantics:READ_Block Allocable Unit.request(Block Allocable Unit Transaction Identifier, Block Allocable Unit List).[END]
The READ_Block Allocable Unit.request primitive shall be passed to the Block Access System provider to request the read of the content of all the Block Allocable Units identified in the Block Allocable Unit List.[END]
Receipt of the READ_Block Allocable Unit.request primitive shall cause the Block Access Systemprovider to read the content of all the Block Allocable Units identified in the Block Allocable Unit List provided as parameter from the Storage Media.[END]
The READ_Block Allocable Unit.indication primitive shall be used to pass the data read from Block Allocable Units to the User Entity.[END]
The READ_Block Allocable Unit.indication primitive shall use the following semantics:READ_Block Allocable Unit.indication(Block Allocable Unit Transaction Identifier, Block Allocable Unit List Content, Block Allocable Unit Result Metadata).[END]
The READ_Block Allocable Unit.indication primitive shall be passed by the Block Access System provider to the requesting User Entity in response to the READ_Block Allocable Unit.request with Block Allocable Unit Result Metadata indicating if the request was executed successfully or not.[END]
When READ_Block Allocable Unit.request is successful, the Block Allocable Unit List Content shall provide the data read from Block Allocable Unit List.[END]
When READ_Block Allocable Unit.request is unsuccessful, the Block Allocable Unit Result Metadata shall provide the reason of the failure.[END]
The READ_Block Allocable Unit.indication Result Metadata shall report a failure if any of the requested Block Allocable Unit is not existing in the MMS.[END]
The READ_Block Allocable Unit.indication Result Metadata shall report a failure if any of the requested Block Allocable Unit is disabled.[END]
The READ_Block Allocable Unit.indication Result Metadata shall report a failure if any of the requested Block Allocable Unit is locked by another User Entity in Exclusive_Read_Only or Exclusive_Access modes.[END]
The WRITE_Block Allocable Unit.request primitive shall be passed to the Block Access System provider to request in-order writing of a list of Block Allocable Units.[END]
The WRITE_Block Allocable Unit.request primitive shall use the following semantics:WRITE_Block Allocable Unit.request(Block Allocable Unit Transaction Identifier, Block Allocable Unit List, Block Allocable Unit List Content).[END]
The WRITE_Block Allocable Unit.request primitive shall be passed to the Block Access System provider to request the write data contained into the Block Allocable Unit List Content into the Block Allocable Units identified in the Block Allocable Unit List.[END]
Receipt of the WRITE_Block Allocable Unit.request primitive shall cause the Block Access Systemprovider to write on the Storage Media the data contained into the Block Allocable Unit List Content considering Block Allocable Units identified in the Block Allocable Unit List.[END]
The WRITE_Block Allocable Unit.indication primitive shall be used to indicate the outcome of the data writing on the Storage Media.[END]
The WRITE_Block Allocable Unit.indication primitive shall use the following semantics:WRITE_Block Allocable Unit.indication(Block Allocable Unit Transaction Identifier, Block Allocable Unit Result Metadata).[END]
The WRITE_Block Allocable Unit.indication primitive shall be passed by the Block Access Systemprovider to the requesting User Entity in response to the WRITE_Block Allocable Unit.request with Block Allocable Unit Result Metadata indicating if the request was executed successfully or not.[END]
When WRITE_Block Allocable Unit.request is unsuccessful, the Block Allocable Unit Result Metadata shall provide the reason of the failure.[END]
The WRITE_Block Allocable Unit.indication Block Allocable Unit Result Metadata shall report a failure if any of the requested Block Allocable Unit is not existing in the MMS.[END]
The WRITE_Block Allocable Unit.indication Block Allocable Unit Result Metadata shall report a failure if any of the requested Block Allocable Unit is disabled.[END]
The WRITE_Block Allocable Unit.indication Block Allocable Unit Result Metadata shall report a failure if any of the requested Block Allocable Unit is locked by another User Entity in any mode.[END]
The ERASE_Block Allocable Unit.request primitive shall be passed to the Block Access System provider to request in-order erasing of a list of Block Allocable Units.[END]
The ERASE_Block Allocable Unit.request primitive shall use the following semantics:ERASE_Block Allocable Unit.request(Block Allocable Unit Transaction Identifier, Block Allocable Unit List, Block Allocable Unit Erase Pattern).[END]
The ERASE_Block Allocable Unit.request primitive shall be passed to the Block Access System provider to request the erasing of the content of all the Block Allocable Units identified in the Block Allocable Unit List.[END]
Receipt of the ERASE_Block Allocable Unit.request primitive shall cause the Block Access Systemprovider to write the provided Block Allocable Unit Erase Pattern parameter in the content of all the Block Allocable Units identified in the Block Allocable Unit list provided as parameter from the Storage Media.[END]
The ERASE_Block Allocable Unit.indication primitive shall be used to indicate the outcome of the erasing of the Block Allocable Units on the Storage Media.[END]
The ERASE_Block Allocable Unit.indication primitive shall use the following semantics:ERASE_Block Allocable Unit.indication(Block Allocable Unit Transaction Identifier, Block Allocable Unit Result Metadata).[END]
The ERASE_Block Allocable Unit.indication primitive shall be passed by the Block Access Systemprovider to the requesting User Entity in response to the ERASE_Block Allocable Unit.request with Block Allocable Unit Result Metadata indicating if the request was executed successfully or not.[END]
When ERASE_Block Allocable Unit.request is unsuccessful, the Block Allocable Unit Result Metadata shall provide the reason of the failure.[END]
The ERASE_Block Allocable Unit.indication Block Allocable Unit Result Metadata shall report a failure if any of the requested Block Allocable Unit is not existing in the MMS.[END]
The ERASE_Block Allocable Unit.indication ERASE Result Metadata shall report a failure if any of the requested Block Allocable Unit is disabled.[END]
The ERASE_Block Allocable Unit.indication ERASE Result Metadata shall report a failure if any of the requested Block Allocable Unit is locked by another User Entity in any mode.[END]
The DISABLE_Block Allocable Unit.request primitive shall be passed to the Block Access System provider to request disabling a list of Block Allocable Units.[END]
The DISABLE_Block Allocable Unit.request primitive shall use the following semantics:DISABLE_Block Allocable Unit.request(Block Allocable Unit Transaction Identifier, Block Allocable Unit List).[END]
The DISABLE_Block Allocable Unit.request primitive shall be passed to the Block Access Systemprovider to request the disabling of all the Block Allocable Units identified in the Block Allocable Unit List.[END]
Receipt of the DISABLE_Block Allocable Unit.request primitive shall cause the Block Access Systemprovider to disable all the Block Allocable Units identified in the Block Allocable Unit list provided as parameter.[END]
The DISABLE_Block Allocable Unit.indication primitive shall be used to indicate the outcome of the disabling of the Block Allocable Units identified in the Block Allocable Unit List provided as parameter.[END]
The DISABLE_Block Allocable Unit.indication primitive shall use the following semantics:DISABLE_Block Allocable Unit.indication(Block Allocable Unit Transaction Identifier, Block Allocable Unit Result Metadata).[END]
The DISABLE_Block Allocable Unit.indication primitive shall be passed by the Block Access Systemprovider to the requesting User Entity in response to the DISABLE_Block Allocable Unit.request with Block Allocable Unit Result Metadata indicating if the request was executed successfully or not.[END]
When DISABLE_Block Allocable Unit.request is unsuccessful, the Block Allocable Unit Result Metadata shall provide the reason of the failure.[END]
The DISABLE_Block Allocable Unit.indication Result Metadata shall report a failure if any of the requested Block Allocable Unit is not existing in the MMS.[END]
The ENABLE_Block Allocable Unit.request primitive shall be passed to the Block Access System provider to request enabling a list of Block Allocable Units.[END]
The ENABLE_Block Allocable Unit.request primitive shall use the following semantics:ENABLE_Block Allocable Unit.request(Block Allocable Unit Transa ction Identifier, Block Allocable Unit List).[END]
The ENABLE_Block Allocable Unit.request primitive shall be passed to the Block Access System provider to request the enabling of all the Block Allocable Units identified in the Block Allocable Unit List.[END]
When enabling a Block Allocable Unit, the Block Access System provider shall reset any information related to the locking status of the Block Allocable Unit.[END]
Receipt of the ENABLE_Block Allocable Unit.request primitive shall cause the Block Access Systemprovider to enable all the Block Allocable Units identified in the Block Allocable Unit list provided as parameter.[END]
The ENABLE_Block Allocable Unit.indication primitive shall be used to indicate the outcome of the enabling of the Block Allocable Units identified in the Block Allocable Unit List provided as parameter.[END]
The ENABLE_Block Allocable Unit.indication primitive shall use the following semantics:ENABLE_Block Allocable Unit.indication(Block Allocable Unit Transaction Identifier, Block Allocable Unit Result Metadata).[END]
The ENABLE_Block Allocable Unit.indication primitive shall be passed by the Block Access Systemprovider to the requesting User Entity in response to the ENABLE_Block Allocable Unit.request with Block Allocable Unit Result Metadata indicating if the request was executed successfully or not.[END]
When ENABLE_Block Allocable Unit.request is unsuccessful, the Block Allocable Unit Result Metadata shall provide the reason of the failure.[END]
The ENABLE_Block Allocable Unit.indication Result Metadata shall report a failure if any of the requested Block Allocable Unit is not existing in the MMS.[END]
The LOCK_Block Allocable Unit.request primitive shall be passed to the Block Access System provider to request the locking of a list of Block Allocable Units.[END]
The LOCK_Block Allocable Unit.request primitive shall use the following semantics:LOCK_Block Allocable Unit.request(Block Allocable Unit Transaction Identi fier, Block Allocable Unit List, Block Allocable Unit Lock Type, User Entity Identifier).[END]
The LOCK_Block Allocable Unit.request primitive shall be passed to the Block Access System provider to request the locking of all the Block Allocable Units identified in the Block Allocable Unit List.[END]
Receipt of the LOCK_Block Allocable Unit.request primitive shall cause the Block Access System provider to lock all the Block Allocable Units identified in the Block Allocable Unit list provided as parameter.[END]
The LOCK_Block Allocable Unit.indication primitive shall be used to indicate the outcome of the lockingof the Block Allocable Units identified in the Block Allocable Unit list provided as parameter.[END]
The LOCK_Block Allocable Unit.indication primitive shall use the following semantics:LOCK_Block Allocable Unit.indication(Block Allocable Unit Transaction Identifier, Block Allocable Unit Result Metadata).[END]
The LOCK_Block Allocable Unit.indication primitive shall be passed by the Block Access System provider to the requesting User Entity in response to the LOCK_Block Allocable Unit.request with Block Allocable Unit Result Metadata indicating if the request was executed successfully or not.[END]
When LOCK_Block Allocable Unit.request is unsuccessful, the Block Allocable Unit Result Metadata shall provide the reason of the failure.[END]
The LOCK_Block Allocable Unit.indication Block Allocable Unit Result Metadata shall report a failure if any of the requested Block Allocable Unit is not existing in the MMS.[END]
The LOCK_Block Allocable Unit.indication Block Allocable Unit Result Metadata shall report a failure if any of the requested Block Allocable Unit is disabled.[END]
The LOCK_Block Allocable Unit.indication Block Allocable Unit Result Metadata shall report a failure if any of the requested Block Allocable Unit is locked by another User Entity in any mode.[END]
The UNLOCK_Block Allocable Unit.request primitive shall be passed to the Block Access System provider to request the unlocking of a list of Block Allocable Units.[END]
The UNLOCK_Block Allocable Unit.request primitive shall use the following semantics:UNLOCK_Block Allocable Unit.request(Block Allocable Unit Transaction Identifier, Block Allocable Unit List, User Entity Identifier).[END]
The UNLOCK_Block Allocable Unit.request primitive shall be passed to the Block Access System provider to request the unlocking of all the Block Allocable Units identified in the Block Allocable Unit List.[END]
Receipt of the UNLOCK_Block Allocable Unit.request primitive shall cause the Block Access Systemprovider to unlock all the Block Allocable Units identified in the Block Allocable Unit list provided as parameter.[END]
The UNLOCK_Block Allocable Unit.indication primitive shall be used to indicate the outcome of the unlocking of the Block Allocable Units identified in the Block Allocable Unit list provided as parameter.[END]
The UNLOCK_Block Allocable Unit.indication primitive shall use the following semantics:UNLOCK_Block Allocable Unit.indication(Block Allocable Unit Transactio n Identifier, Block Allocable Unit Result Metadata).[END]
The UNLOCK_Block Allocable Unit.indication primitive shall be passed by the Block Access Systemprovider to the requesting User Entity in response to the UNLOCK_Block Allocable Unit.request with Block Allocable Unit Result Metadata indicating if the request was executed successfully or not.[END]
When UNLOCK_Block Allocable Unit.request is unsuccessful, the Block Allocable Unit Result Metadata shall provide the reason of the failure.[END]
The UNLOCK_Block Allocable Unit.indication Block Allocable Unit Result Metadata shall report a failure if any of the requested Block Allocable Unit is not existing in the MMS.[END]
The UNLOCK_Block Allocable Unit.indication Block Allocable Unit Result Metadata shall report a failure if any of the requested Block Allocable Unit is disabled.[END]
The UNLOCK_Block Allocable Unit.indication Block Allocable Unit Result Metadata shall report a failure if any of the requested Block Allocable Unit is locked by another User Entity in any mode.[END]
The MMS shall provide a User Entity the ability to create a Store.[END]
The MMS shall provide a User Entity the ability to delete a Store.[END]
The MMS shall provide a User Entity the ability to expand a Store.[END]
The MMS shall provide a User Entity the ability to reduce a Store.[END]
The MMS shall provide a User Entity the ability to lock a Store.[END]
The MMS shall provide a User Entity the ability to unlock a Store.[END]
The MMS shall provide a User Entity the ability to erase a Store.[END]
The Store Identifier parameter shall uniquely identify a Store.[END]
The Store Lock Type parameter shall specify a lock action on a Store. Possible values are:-Exclusive_Read_Only : The lock-owner can only read from the Store. Other user entities cannot read from or write to the Store;-Read_Only : The lock-owner can only read from the Store. Other user entities can only read from the Store (i.e. everyone can read);-Exclusive_Access : The lock-owner can read from and write to the Store. Other user entities cannot read from or write to the Store;-Single_Writer : The lock-owner can read from and write to the Store. Other user entities can only read from the Store.[END]
The Store Transaction Identifier shall be a value, assigned by the invoking User Entity, which is subsequently used to associate indication primitives with the causal request primitives.[END]
The Store Result Metadata parameter shall be used to provide information generated by the MMS provider to the User Entity regarding result of the execution of a request.[END]
The MMS shall provide the following primitives:-CREATE_STORE.request, CREATE_STORE.indication-DELETE_STORE.request, DE LETE_STORE.indication-EXPAND_STORE.request, EXPAND_STORE.indication-REDUCE_STORE.request, REDUCE_STORE.indication-LOCK_STORE.request, LOCK_STORE.indication-UNLOCK_STORE.request, UNLOCK_STORE.indication-ERASE_STORE.request, ERASE_STORE.indication[END]
The CREATE_STORE.request primitive shall be passed to the MMS provider to request the creation of a Store.[END]
The CREATE_STORE.request primitive shall use the following semantics:CREATE_STORE.request(Store Transaction Identifier, Block Allocable Unit List, Store Identifier).[END]
The CREATE_STORE.request primitive shall be passed to the MMS provider to request the creation of a Store made of all the Block Allocable Units identified in the Block Allocable Unit List.[END]
Receipt of the CREATE_STORE.request primitive shall cause the MMS provider to create a Store and associate to this Store all the Block Allocable Units identified in the Block Allocable Unit list provided as parameter.[END]
The CREATE_STORE.indication primitive shall be used to indicate the outcome of the creation of a store.[END]
The CREATE_STORE.indication primitive shall use the following semantics:CREATE_STORE.indication(Store Transaction Identifier, Store Result Metadata).[END]
The CREATE_STORE.indication primitive shall be passed by the MMS provider to the requesting User Entity in response to the CREATE_STORE.request with Store Result Metadata indicating if the request was executed successfully or not.[END]
When CREATE_STORE.request is unsuccessful, the Store Result Metadata shall provide the reason of the failure.[END]
The CREATE_STORE.indication Store Result Metadata shall report a failure if any of the requested Block Allocable Unit is not existing in the MMS.[END]
The CREATE_STORE.indication Store Result Metadata shall report a failure if any of the requested Block Allocable Unit is already associated to any other Store.[END]
The DELETE_STORE.request primitive shall be passed to the MMS provider to request the deletion of a Store.[END]
The DELETE_STORE.request primitive shall use the following semantics:DELETE_STORE.request(Store Transaction Identifier, Store Identifier).[END]
The DELETE_STORE.request primitive shall be passed to the MMS provider to request the deletion of a Store and dissociate the Block Allocable Units identified in the Block Allocable Unit List from the Store.[END]
Receipt of the DELETE_STORE.request primitive shall cause the MMS provider to delete a Store and dissociate from the Store all the Block Allocable Units identified in the Block Allocable Unit list provided as parameter.[END]
The DELETE_STORE.indication primitive shall be used to indicate the outcome of the deletion of a Store.[END]
The DELETE_STORE.indication primitive shall use the following semantics:DELETE_STORE.indication(Store Transactio n Identifier, Store Result Metadata).[END]
The DELETE_STORE.indication primitive shall be passed by the MMS provider to the requesting User Entity in response to the DELETE_STORE.request with Store Result Metadata indicating if the request was executed successfully or not.[END]
When DELETE_STORE.request is unsuccessful, the Store Result Metadata shall provide the reason of the failure.[END]
The DELETE_STORE.indication Store Result Metadata shall report a failure if any of the Block Allocable Unit associated to the Store is locked by any other User Entity.[END]
The DELETE_STORE.indication Store Result Metadata shall report a failure if the Store is locked by any other User Entity.[END]
The EXPAND_STORE.request primitive shall be passed to the MMS provider to request the expansion of a Store.[END]
The EXPAND_STORE.request primitive shall use the following semantics:EXPAND_STORE.request(Store Transaction Identifier, Block Allocable Unit List, Store Identifier).[END]
The EXPAND_STORE.request primitive shall be passed to the MMS provider to request the expansion of a Store by adding all the Block Allocable Units identified in the Block Allocable Unit List to the list of Block Allocable Units already associated to the Store.[END]
Receipt of the EXPAND_STORE.request primitive shall cause the MMS provider to expand a Store and add to this Store all the Block Allocable Units identified in the Block Allocable Unit list provided as parameter.[END]
The MMS shall ensure that the data contained in the Block Allocable Units that are already part of a Store are preserved.[END]
The EXPAND_STORE.indication primitive shall be used to indicate the outcome of the expansion of a store.[END]
The EXPAND_STORE.indication primitive shall use the following semantics:EXPAND_STORE.indication(Store Transaction Identifier, Store Result Metadata).[END]
The EXPAND_STORE.indication primitive shall be passed by the MMS provider to the requesting User Entity in response to the EXPAND_STORE.request with Store Result Metadata indicating if the request was executed successfully or not.[END]
When CREATE_STORE.request is unsuccessful, the Store Result Metadata shall provide the reason of the failure.[END]
The EXPAND_STORE.indication Store Result Metadata shall report a failure if any of the requested Block Allocable Unit is not existing in the MMS.[END]
The EXPAND_STORE.indication StoreResult Metadata shall report a failure if any of the Block Allocable Unit identified in the Block Allocable Unit List is already associated to any other Store.[END]
The EXPAND_STORE.indication Store Result Metadata shall report a failure if the Store is locked by any other User Entity.[END]
The REDUCE_STORE.request primitive shall be passed to the MMS provider to request the reduction of a Store.[END]
The REDUCE_STORE.request primitive shall use the following semantics:REDUCE_STORE.request(Store Transaction Identifier, Block Allocable Unit List, Store Identifier).[END]
The REDUCE_STORE.request primitive shall be passed to the MMS provider to request the reduction of a Store by dissociating all the Block Allocable Units identified in the Block Allocable Unit List from the list of Block Allocable Units already associated to the Store.[END]
Receipt of the REDUCE_STORE.request primitive shall cause the MMS provider to reduce a Store and dissociate from the Store all the Block Allocable Units identified in the Block Allocable Unit list provided as parameter.[END]
The REDUCE_STORE.indication primitive shall be used to indicate the outcome of the reduction of  a store.[END]
The REDUCE_STORE.indication primitive shall use the following semantics:REDUCE_STORE.indication(Store Transaction Identifier, Store Result Metadata).[END]
The REDUCE_STORE.indication primitive shall be passed by the MMS provider to the requesting User Entity in response to the REDUCE_STORE.request with Store Result Metadata indicating if the request was executed successfully or not.[END]
When REDUCE_STORE.request is unsuccessful, the Store Result Metadata shall provide the reason of the failure.[END]
The REDUCE_STORE.indication Store Result Metadata shall report a failure if any of the Block Allocable Unit identified in the Block Allocable Unit List is not associated to the Store.[END]
The REDUCE_STORE.indication Store Result Metadata shall report a failure if any of the Block Allocable Unit identified in the Block Allocable Unit List is locked by another User Entity.[END]
The REDUCE_STORE.indication Store Result Metadata shall report a failure if the Store is locked by any other User Entity.[END]
The LOCK_STORE.request primitive shall be passed to the MMS provider to request the locking of a Store[END]
The LOCK_STORE.request primitive shall use the following semantics:LOCK_STORE.request(Store Transaction Identifier, Store Identifier, Store Lock Type, User Entity Identifier).[END]
The LOCK_STORE.request primitive shall be passed to the MMS provider to request the locking of the complete Store.[END]
Receipt of the LOCK_STORE.request primitive shall cause the MMS provider to lock the complete Store identified by Store Identifier parameter.[END]
The LOCK_STORE.indication primitive shall be used to indicate the outcome of the locking of the Store identified by the Store Identifier provided as parameter.[END]
The LOCK_STORE indication primitive shall use the following semantics:LOCK_STORE.indication(Store Transaction Identifier, Store Result Metadata).[END]
The LOCK_STORE.indication primitive shall be passed by the MMS provider to the requesting User Entity in response to the LOCK_STORE.request with Store Result Metadata indicating if the request was executed successfully or not.[END]
When LOCK_STORE.request is unsuccessful, the Store Result Metadata shall provide the reason of the failure.[END]
The LOCK_STORE.indication Store Result Metadata shall report a failure if Store identified by the Store Identifier does not exist.[END]
The LOCK_STORE.indication Store Result Metadata shall report a failure if Store identified by the Store Identifier is locked by another User Entity in any mode.[END]
The UNLOCK_STORE.request primitive shall be passed to the MMS provider to request the unlocking of a Store.[END]
The UNLOCK_STORE.request primitive shall use the following semantics:UNLOCK_STORE.request(Store Transaction Identifier, Store Identifier, User Entity Identifier).[END]
The UNLOCK_STORE.request primitive shall be passed to the MMS provider to request the unlocking of the Store identified by the Store Identifier provided as parameter.[END]
Receipt of the UNLOCK_STORE.request primitive shall cause the MMS provider to unlock the Store identified by the Store Identifier provided as parameter.[END]
The UNLOCK_STORE.indication primitive shall be used to indicate the outcome of the unlocking of the Store identified by the Store Identifier provided as parameter.[END]
The UNLOCK_STORE.indication primitive shall use the following semantics:UNLOCK_STORE.indication(Store Transaction Identifier, Store Result Metadata).[END]
The UNLOCK_STORE.indication primitive shall be passed by the MMS provider to the requesting User Entity in response to the UNLOCK_STORE.request with Store Result Metadata indicating if the request was executed successfully or not.[END]
When UNLOCK_STORE.request is unsuccessful, the Store Result Metadata shall provide the reason of the failure.[END]
The UNLOCK_STORE.indication Store Result Metadata shall report a failure if any of the requested Store is not existing in the MMS.[END]
The UNLOCK_STORE.indication Store Result Metadata shall report a failure if the Store to unlock is locked by another User Entity in any mode.[END]
The ERASE_STORE.request primitive shall be passed to the MMS provider to request the erase of a Store.[END]
The ERASE_STORE.request primitive shall use the following semantics:ERASE_STORE.request(Store Transaction Identifier, Store Identifier).[END]
The ERASE_STORE.request primitive shall be passed to the MMS provider to request the erase of the Store identified by the Store Identifier provided as parameter.[END]
Receipt of the ERASE_STORE.request primitive shall cause the MMS provider to erasethe Store identified by the Store Identifier provided as parameter.[END]
The ERASE_STORE.indication primitive shall be used to indicate the outcome of the erasing of the Store identified by the Store Identifier provided as parameter.[END]
The ERASE_STORE.indication primitive shall use the following semantics:ERASE_STORE.indication(Store Transaction Identifier, Store Result Metadata).[END]
The ERASE_STORE.indication primitive shall be passed by the MMS provider to the requesting User Entity in response to the ERASE_STORE.request with Store Result Metadata indicating if the request was executed successfully or not.[END]
When ERASE_STORE.request is unsuccessful, the Store Result Metadata shall provide the reason of the failure.[END]
The ERASE_STORE.indication Store Result Metadata shall report a failure if any of the requested Store is not existing in the MMS.[END]
The ERASE_STORE.indication Store Result Metadata shall report a failure if the Store to erase is locked by another User Entity in any mode.[END]
The File Management System shall provide a User Entity the ability to create a File.[END]
The File Management System shall provide a User Entity the ability to open an existing File.[END]
The File Management System shall provide a User Entity the ability to close an opened File.[END]
The File Management System shall provide a User Entity the ability to write data into an opened File.[END]
The File Management System shall provide a User Entity the ability to read data from an opened File.[END]
The File Management System shall provide a User Entity the ability to identify from which location of an opened File the data will be read.[END]
The File Management System shall provide a User Entity the ability to retrieve all the information related to an existing File.[END]
The File Management System shall provide a User Entity the ability to delete an existing File.[END]
The File Management System shall provide a User Entity the ability to copy an existing File.[END]
The File Management System shall provide a User Entity the ability to move an existing file.[END]
The File Management System shall provide a User Entity the ability to create a Directory.[END]
The File Management System shall provide a User Entity the ability to delete an existing Directory.[END]
The File Management System shall provide a User Entity the ability to delete an existing Directory.[END]
The File Management System shall provide a User Entity the ability to set attributes defined for a Directory.[END]
The File Management System shall provide a User Entity the ability to retrieve the attributes associates to an existing Directory.[END]
The File Management System shall provide a User Entity the ability to lock the access to an existing File.[END]
The File Management System shall provide a User Entity the ability to unlock the access to an existing File.[END]
The File Management System shall provide a User Entity the ability to retrieve the list of the locked Files.[END]
The File Management System shall provide a User Entity the ability to find Files located in a Directory.[END]
The File Management System shall provide a User Entity the ability to map an interface to an existing File.[END]
The File Management System shall provide a User Entity the ability to set attributes defined for a File.[END]
The File Management System shall provide a User Entity the ability to retrieve the attributes associates to an existing File.[END]
The File Management System shall provide a User Entity the ability to ensure that all the data are currently stored into an opened File.[END]
The File Management System shall provide a User Entity the ability to reduce the size of an existing File.[END]
The File Management System shall provide a User Entity the ability to get the checksum of a File.[END]
The File Management System shall provide a User Entity the ability to suspend the copy of a File.[END]
The File Management System shall provide a User Entity the ability to resume the copy of a File that has been previously suspended.[END]
The File Management System shall provide a User Entity the ability to abort a File Copy operation.[END]
The File Management System shall provide a User Entity the ability to get the current status of a File Copy operation.[END]
The File Management System shall provide a User Entity the ability to receive events related to the progress of a File Copy operations.[END]
The File Management System shall provide a User Entity the ability to register to File Management System Events.[END]
The File Management System shall provide a User Entity the ability to unregister to File Management System Events.[END]
The File Management System shall provide a User Entity the ability to receive File Management System Events.[END]
The File Management System shall provide a User Entity the ability to retrieve the Block Allocable Unit list that is used by the File Management System to store the data stored.[END]
The File Management System shall provide a User Entity the ability to defragment the files.[END]
The File Management System shall provide a User Entity the ability to force the segmentation of a file mapped to an input interface.[END]
The Absolute File Offset parameter shall indicate the desired octet offset from the start of that file at which data is to be read from or written to. It can be either positive or null.[END]
The Attribute parameter is identified by an Attribute Identifier and defined by an Attribute Type, an Attribute Size and an Attribute Value.[END]
The Attribute Identifier parameter shall identify one specific Attribute of a file.[END]
The Attribute List parameter shall identify a list of Attribute.[END]
The Attribute Size parameter shall be the size of the Attribute Value.[END]
The Attribute Type parameter shall correspond to the type of an Attribute Value currently associated or to be associated to an Attribute, i.e.:-INT64: an integer represented over 64 bits,-DOUBLE: a floating-point value, represented over 64 bits,-STRING: an array of ASCII characters of ‘Attribute Size’ maximum length,-BINARY: an array of bytes, of ‘Attribute Size’ maximum size.[END]
The Attribute Value parameter shall be the value currently associated or to be associated to an Attribute.[END]
The Base Directory Full Path parameter shall be the Directory Full Path identifying the directory from which the search operation is to be performed.[END]
The Destination File Full Path parameter shall be the File Full Path of the copied or moved file.[END]
The Directory Full Path parameter shall uniquely identify a directory at File Management System level by gathering its Directory Path and Directory Name [END]
The Directory Listing parameter shall be used to list the files and subdirectories contained within a directory, providing at least the following information: - Directory Full Path (only once),- And for each child entity:- Name of the child entity (i.e. Directory Name or File Name),- Type of the child entity (among FILE and DIRECTORY).[END]
The Directory Name parameter shall be a string or integer used to uniquely identify a directory within its parent.[END]
A specific Directory Name identified as Root Directory Name shall identify the top-level directory of a File Store.[END]
Each File Store shall be identified by a unique Directory Name giving access to its root directory.[END]
The Directory Path parameter shall be an identifier used to locate a directory within the File Management System organization.[END]
The Directory hierarchy shall be a string ma de of Directory Name (s) and separator(s).[END]
The Directory Attributes parameter shall be the list of Attributes attached to a directory. [END]
The File Access Type defined the type of access authorised on a file when opened:-Read-Only: the User Entity can only read from the file;-Read-Write: the User Entity can read from and write to the file;-Append: the User Entity can only write at the end of file (no seek allowed).[END]
The File Action When Full Type shall define the action to be performed when a file becomes full:-Close File: when the file gets full, it is closed, and no more writing to the file is possible (unless re-opening it);-Close File & Create Next File: when the file gets full, it is closed, and a new file is created (if not existing) to continue data storage without losing any data.[END]
The File Attributes parameter shall be the list of Attributes attached to a file, complementary to its content. [END]
The File Checksum parameter shall be the computed checksum of a file.[END]
The Checksum function shall be defined at mission design level and identified at File Management System level. [END]
The File Closed parameter shall indicate if the file was closed or not by a write operation (WRITE_TO_FILE.request).[END]
The Copy Identifier parameter shall be used to logically identify an initiated file copy operation managed by a File Management System.[END]
The Copy Status parameter shall be used to report information about an initiated file copy, including:-Copy Identifier – identifies the copy operation.-State – indicates the current state of the copy operation among STARTED, SUSPENDED, COMPLETED, and ABORTED.-Overall Progress – indicates the progression percentage (copied / source file’s size * 100).[END]
The File Copy States transitions parameter shall be:-STARTED to COMPLETED when end of Source file is reached.-STARTED to SUSPENDED on SUSPEND_FILE_COPY request-SUSPENDED to STARTED on RESUME_FILE_COPY request-STARTED to ABORTED on ABORT_FILE_COPY request-SUSPENDED to ABORTED on ABORT_FILE_COPY request[END]
The File Descriptor parameter shall be used to logically identify an opened file among all the File Stores managed by a File Management System.[END]
The File Full Path parameter shall uniquely identify a file at File Management System level by gathering its File Path an d File Name.[END]
The File Mapping Type shall identify the type of mapping applied to a file:-Exclusive: all data received on a single input interface has to be stored into the file,-Protocol Address: all data received on a set of input interfaces with a given Data Link layer address has to be stored into the file,-Packet Application Identifier: all packets received on a set of input interfaces with a given Application Identifier have to be stored into the file,-Custom Packet Field: all packets received on a set of input interfaces with a given packet field value have to be stored into the file,-Packet Packet Utilisation Standard Service: all Packet Utilisation Standard packets received on a set of input interfaces with a given service have to be stored into the file,-Packet Packet Utilisation Standard Service & Subservice: all Packet Utilisation Standard packets received on a set of input interfaces with a given (service, subservice) have to be stored into the file,-Packet Application Identifier, Packet Utilisation Standard Service & Subservice: all Packet Utilisation Standard packets received on a set of input interfaces with a given triplet (Application Identifier, service, subservice) have to be stored into the file.[END]
The File Mapping Configuration shall identify the information required to perform the mapping of data to a file. This includes:-Protocol Address: identifies the Data Link layer address (e.g. SpaceWire address, 1553 address and sub-address, etc.) when Protocol Address mapping is requested.-Packet Application Identifier: identifies the Packet Application Process Identifier when either Packet Application Identifier or Packet Application Identifier, Packet Utilisation Standard Service & Subservice mapping is requested.-Custom Packet Field: identifies the characteristics of the custom field when Custom Packet Field mapping is requested:oOffset: identifies the field offset from the beginning of the PacketoValue: identifies the reference value used for field comparisonoSize: identifies the field sizeoComparison operator: identifies the operat or (e.g. >, <, =) to be applied to check packet field matching against the reference value.-Packet Packet Utilisation Standard Service: identifies the Packet Utilisation Standard service when either Packet Packet Utilisation Standard Service, Packet Packet Utilisation Standard Service & Subservice or Pa cket Application Identifier, Packet Utilisation Standard Service & Subservice mapping is requested.-Packet Packet Utilisation Standard Subservice: identifies the Packet Utilisation Standard subservice when either Packet Packet Utilisation Standard Service &Subservice or Packet Application Identifier, Packet Utilisation Standard Service & Subservice mapping is requested.[END]
The File Name parameter shall be a string or integer used to uniquely identify a file within a directory (in a File Store).[END]
The File Lock Type parameter shall specify a lock action on a file. Possible values are:-Exclusive_Read_Only: The lock-owner can only read from the file. Other user entities cannot read from or write to the file;-Read_Only: The lock-owner can only read from the file. Other user entities can only read from the file (i.e. everyone can read);-Exclusive_Access: The lock-owner can read from and write to the file. Other user entities cannot read from or write to the file;-Single_Writer: The lock-owner can read from and write to the file. Other user entities can only read from the file.[END]
The File Opening Criteria parameter shall indicate the criteria to be applied to a file when opened:-File Access Type: define the authorisation of User Entity opening the file.-Create mode flag: if specified and the file does not exist it will be created.-File Lock Type (optionally): if specified, the file is locked atomically when opened.-File Action When Full (optionally): Applicable only when Access Type is “Append”.-File Packet Storage flag (optionally): Applicable only when Access Type is “Append”, when specified, the file is used exclusively to store complete Packets (i.e. that shall not be split), available only to File Stores supporting the definition of Maximum Size.-Other specific fields may be defined depending on the mission[END]
The File Path parameter shall be an identifier used to locate a file within the File Management System organization.[END]
The Result Metadata parameter shall be used to provide information generated by the File Management System provider to the User Entity regarding successful or failed result of a primitive.[END]
The File Segment parameter shall be the data segment read from a file or to be written to a file.[END]
The File Segment Length parameter shall indicate the length in octets of the data to be read or written for a request, and the effective length or data read or written in an indication primitive.[END]
The File Selection Pattern parameter shall be used to specify the pattern to be applied on any information/characteristic available in File Status in order to search for specific file(s).[END]
The File Size parameter shall indicate the number of data octets forming the file content.[END]
The File Size Allocation parameter shall indicate if the allocation of the data storage area required to store data in the File shall be done at the time of creation of the File.[END]
The File Status parameter shall be used to list the information related to the file current state:-File Name identifies the file.-Creation Time (optionally) is the time at which the file was created.-Last Read Time (optionally) is the time at which the file was last read.-Last Write Time (optionally) is the time at which the file was last written to.-Lock Identifier (optionally) identifies a lock on the file (if locked).-Lock Type (optionally) identifies the type of lock (if locked).-Lock Owner (optionally) identifies the User Entity owning the lock (if locked).-Size is the current size of content (data) in octets.-Allocated Size (optionally) is the effective size occupied by the file within the Store, in octets. It is always a multiple of the Store Block Allocable Unit size.-Maximum Size (optionally) indicates the size that cannot be exceeded by content if specified at creation.-Mapping Criteria (optionally) identifies all mapping criteria currently associated to the file.-Opened indicates whether the file is currently open by at least one User Entity or not.[END]
The File Management System Event parameter shall be used to list the characteristics of a reported event:-Type identifies the kind of operation reported (creation, auto-closing, deletion).-Store identifier-Source File Path is the full path to the source file at the origin of this event.-Destination File Path (optional) is the full path to the destination file at the origin of this event (for operations involving a destination file identification).-Event Sequence Counter is a counter incremented for each generated event (for time ordering).[END]
The Force parameter shall be used to force deletion of a currently open file (whatever the User Entity).[END]
The Found Files List parameter shall contain the list of the full path of all files that matched a specific File Selection Pattern[END]
The Locked Files List parameter references all currently locked files that shall be maintain and referred as Locked Files List parameter. [END]
The Locked Files List parameter shall contain lock characteristics of all locked files:-File Path identifies the full path to the file upon which the lock is applied;-Lock Identifier identifies a lock on a file;-Lock Type identifies the type of lock applied;-Lock Owner identifies the User Entity owning the lock.-[END]
The Lock identifier parameter shall be used to logically identify a lock applied on a file.[END]
The Mapping Criteria shall indicate the criteria to be associated to a file for configuration of autonomous data storage:-File Mapping Type: identifies how data have to be associated to a file.-Interface Identifier: identifies the input interface concerned by the mapping.-File Mapping Configuration: identifies the filtering configuration.-Maximum File Size: identifies the amount of data to stop into mapped files.-Continuous Storage: if specified, the storage must continue in new files (successively created, and up to the File Store capacity) when mapped file gets full.-Proxy Mapping: if specified, the input interfaces used for acquisition must be those of the remote MM (only applicable when the File is located into a remote File Store).[END]
The Maximum File Size parameter shall indicate the size in octets that cannot be exceeded by file content.[END]
The Monitored Events parameter shall indicate the event or group of events to be registered with a directory or unregistered from it, among:-FILE_CREATE: report of any file creation, either by direct request from a User Entity or indirectly performed by the File Management System (e.g. in the frame of a file copy, autonomous storage, etc.).-FILE_AUTOCLOSE: report of any file closing by the File Management System as the result of a Full File Action (direct file closing by a User Entity is excluded). -FILE_DELETE: report of any file deletion, either by direct request from a User Entity or indirectly performed by the File Management System (e.g. in the frame of a file move).-Any Combination of the above events (including the three ones).[END]
The New Directory Name parame ter shall be the resulting Di rectory Name once renamed.[END]
The Old Directory Full Path parameter shall be the Directory Full Path identifying the directory to be renamed.[END]
The Recursive parameter shall specify that the registered event(s) also have to be monitored in all sub-directories of the specified directory.[END]
The Relative File Offset parameter shall indicate the desired octet offset from a reference position within a file (start of file, current position, end of file) at which data is to be read from or written to. It can be either positive, negative or null.[END]
The Resulting File Offset parameter shall indicate the byte offset from the beginning of file (i.e. new value of File Descriptor’s current  position). It can be either positive or null.[END]
The Source File Full Path parameter shall be the File Full Path of the file to be copied or moved.[END]
The Transaction Identifier parameter shall be a value, assigned by the invoking User Entity, which is subsequently used to associate indication primitives with the causal request primitives.[END]
The Transaction Identifier shall be unique within the invoking User Entity.[END]
The Whence parameter shall specify the reference position to be considered within a file among:-SEEK_Single-Event Transient: start of file,-SEEK_END: end of file (highest written position),-SEEK_CUR: File Descript or’s current position.-[END]
The following primitives defined in [AD06] shall be supported:-CREATE_FILE.request, CREATE_FILE.indication,-OPEN_FILE.request, OPEN_FILE.indication,-MAP_FILE.request, MAP_FILE.indication,-CLOSE_FILE.request, CLOSE_FILE.indication,-WRITE_TO_FILE.request, WRITE_TO_FILE.indication,-READ_FROM_FILE.request, READ_FROM_FILE.indication,-SEEK_FILE.request, SEEK_FILE.indication,-SHRINK_FILE.request, SHRINK_FILE.indication,-GET_FILE_STATUS.request, GE T_FILE_STATUS.indication,-Single-Event Transient_FILE_ATTRIBUTE.request, SE T_FILE_ATTRIBUTE.indication,-GET_FILE_ATTRIBUTES.request, GE T_FILE_ATTRIBUTES.indication,-DELETE_FILE.request, DE LETE_FILE.indication,-COPY_FILE.request, CO PY_FILE.indication,-MOVE_FILE.request, MO VE_FILE.indication,-CREATE_DIR.request, CREATE_DIR.indication,-LIST_DIR.request, LI ST_DIR.indication,-DELETE_DIR.request, DE LETE_DIR.indication,-RENAME_DIR.request, RENAME_DIR.indication,-LOCK_FILE.request, LOCK_FILE.indication,-UNLOCK_FILE.request, UN LOCK_FILE.indication,-LIST_LOCKED_FILES.request, LIST_LOCKED_FILES.indication,-FIND_FILES.request, FI ND_FILES.indication.-FORCE_FILE_SYNCH.request, FO RCE_FILE_SYNCH.indication,-GET_FILE_CHECKSUM.request, GE T_FILE_CHECKSUM.indication,-SUSPEND_FILE_COPY.request, SU SPEND_FILE_COPY.indication,-RESUME_FILE_COPY.request, RE SUME_FILE_COPY.indication,-ABORT_FILE_COPY.request, ABORT_FILE_COPY.indication,-GET_FILE_COPY_STATUS.request, GET_FILE_COPY_STATUS.indication,-FILE_COPY_EVENT.indication, -REGISTER_File Management System_EVENT.request, REGISTER_File Management System_EVENT.indication,-UNREGISTER_File Management System_EVENT.request, UNREGISTER_File Management System_EVENT.indication,-File Management System_EVENT.indication,-Single-Event Transient_DIR_ATTRIBUTE.request, SE T_DIR_ATTRIBUTE.indication,-GET_DIR_ATTRIBUTES.r equest, GET_DIR_ATTR IBUTES.indication,-GET_Block Allocable Unit_LIST.request, GE T_Block Allocable Unit_LIST.indication,-FILE_DEFRAGMENTATION.request, FI LE_DEFRAGMENTATION.indication-MAP_FILE_SPLIT.request, MA P_FILE_SPLIT.indication [END]
The services shall exclusively use the parameters with the meaning defined in the present specification.[END]
The CREATE_FILE.request primitive shall be passed to the FS provider to request the creation of a new file in a File Store.[END]
The CREATE_FILE.request primitive shall use the following semantics:CREATE_FILE.request (File Transaction Identifier, File Full Path, Maximum File Size (optional), File Size Allocation (optional))[END]
The CREATE_FILE.request primitive shall be passed to the FS provider to request the creation of the specified file. Optionally, it may be requested to limit its maximum sizeand allocate the full capacity at creation.[END]
The CREATE_FILE.request primitive shall cause the FS provider to create the specified file.[END]
In CREATE_FILE.request primitive, the File Name of the File Full Path parameter shall be unique within the parent directory.[END]
In CREATE_FILE.request primitive, the Maxi mum File Size parameter shall be lower than or equal to the limit of the File Store FS.[END]
In CREATE_FILE.request primitive, the File Full Path parameter shall only contain authorized characters (including separators) when string identifiers are used and integers in the allowed range when integer identifiers are used.[END]
In CREATE_FILE.request primitive, the File Path of the File Full Path parameter shall refer to an existing directory.[END]
The CREATE_FILE.indication primitive shall be used to pass the outcome of creating a file to the User Entity.[END]
The CREATE_FILE.indication primitive shall use the following semantics:CREATE_FILE.indication (File Transaction Identifier, File Result Metadata)[END]
The CREATE_FILE.indication primitive shall be passed by the FS provider to the receiving User Entity in response to a CREATE_FILE.request with File Result Metadataindicating if the request was executed successfully or not, and the reason in case of failure.[END]
The CREATE_FILE.indication File Result Metadata shall report a failure if the requested Maximum File Size is greater than the current space available in the File Store.[END]
The CREATE_FILE.indication File Result Metadata shall report a failure if the requested Maximum File Size is negative or null.[END]
The CREATE_FILE.indication File Result Metadata shall report a failure if the requestedFile Name already exists within the parent di rectory (i.e. last dire ctory of the File Full Path).[END]
The CREATE_FILE.indication File Result Metadata shall report a failure if the requested File Full Path is invalid.[END]
The CREATE_FILE.indication File Result Metadata shall report a failure if the requested File Path refers to an inexistent directory.[END]
The OPEN_FILE.request primitive shall be passed to the FS provider to request the opening of an existing file, or the creation and then opening of a new file, for access in a File Store with the specified opening criteria.[END]
The File Management System shall support, as an atomic action, the application of a file lock while opening the file whenever requested by the User Entity.[END]
OPEN_FILE.request Full file action The File Management System shall support the action defined by the User Entity when the file remaining space is not sufficient for appending data segment at end of file.[END]
The OPEN_FILE.request primitive shall use the following semantics:OPEN_FILE.request (Transaction Identifier, File Full Path, File Opening Criteria)[END]
The OPEN_FILE.request primitive shall be passed to the FS provider to request the file to be opened or created and then opened, and optionally be locked.[END]
Receipt of the OPEN_FILE.request primitive shall cause the FS provider to open, or create and open the specified file while granting the user’s entity with the access rights defined in the opening criteria.[END]
The File Descriptor’s current position within the file shall be initialized to the end of file when selecting “Append” Access type in the File Opening Criteria and to the start of the file otherwise.[END]
When a file is autonomously created by the FS provider in answer to the Full File Action parameter, the new created file shall:-inherit the maximum file size of its ancestor (i.e. the currently opened file which misses space for requested data appending),-be opened with exactly the same parameters as its ancestor (File Opening Criteria parameter),-inherit all the file attributes of its ancestor,-inherit any mapping criteria (cf. MAP_FILE.request) of its ancestor,-continue the autonomous data storage without any data loss.[END]
The OPEN_FILE.indication primitive shall be used to indicate the outcome of opening a file to the User Entity.[END]
The OPEN_FILE.indication primitive shall use the following semantics:OPEN_FILE.indication(Transaction Identifier, File Descriptor, File Result Metadata)[END]
The OPEN_FILE.indication primitive shall be passed by the File Management System provider to the receiving User Entity in response to an OPEN_FILE.request with File Result Metadata indicating if the request was executed successfully or if not[END]
When OPEN_FILE.request is successful, the File Result Metadata shall provide the File Descriptor allocated to the opened file (to logically identify it at File Management System level).[END]
When OPEN_FILE.request is unsuccessful, the File Result Metadata shall provide the reason of the failure.[END]
The OPEN_FILE.indication File Result Metadata shall report a failure if the requested access rights in file opening criteria cannot be granted to the User Entity.[END]
The OPEN_FILE.indication File Result Metadata shall report a failure if the application of a lock was requested whereas a lock was already applied to the file.[END]
The OPEN_FILE.indication File Result Metadata shall report a failure if the requested File Full Path refers to an inexistent file and the “Create” parameter was not set.[END]
The OPEN_FILE.indication File Result Metadata shall report a failure if file creation is requested (“Create” parameter is set while file to be opened does not exist) but the Maximum File Size applicable by default to the considered File Store is greater than the current space available in this File Store.[END]
The MAP_FILE.request primitive shall be passed to the FS provider to request autonomous data storage into an existing file, or a succession of files (if Continuous Storage is selected) with respect to the specified mapping criteria.[END]
The MAP_FILE.request primitive shall use the following semantics:MAP_FILE.request(Transaction Identifier, File Full Path, Mapping Criteria)[END]
The MAP_FILE.request primitive shall be passed to the FS provider to request the file to be opened and data received on MM inputs that match the specified Mapping Criteria to be appended to the file.[END]
Receipt of the MAP_FILE.request primitive shall cause the File Management System provider to open the specified file, associate it with the Mapping Criteria and begin autonomous storage with respect to these criteria.[END]
The autonomous data storage shall consist in appending to the file (once successfully opened) all the data received on MM input interfaces that match the associated Mapping Criteria.[END]
Closing the initial file opened by the File Management System when requesting autonomous storage shall cause the Mapping Criteria to be de-associated from the file and no more data matching these Mapping Criteria to be appended to the file.[END]
It shall be possible to associate multiple Mapping Criteria (Exclusive mapping excluded) to a single file, each mapping criteria being considered independently.[END]
Setting the Continuous Storage parameter in the Mapping Criteria shall request the File Management System provider to continue the autonomous storage into a new file without data loss when the currently opened one gets full.[END]
Not setting the Continuous Storage parameter in the Mapping Criteria shall request the File Management System provider to close the file when it gets full.[END]
Setting the Proxy Mapping parameter in the Mapping Criteria when the File Full Pathrefers to a remote File Store shall request the File Management System provider to delegate the mapping operation to the remote File Management System (proxy).[END]
All operations directly related to the mapping criteria shall be performed by the File Management System provider on behalf of the user’s entity at the origin of the MAP_FILE.request.[END]
The File Management System shall discard data received over any of its input interfaces if this data does not match any mapping criteria currently associated to a file.[END]
The MAP_FILE.indication primitive shall be used to indicate to the User Entity the outcome of opening a File for autonomous storage.[END]
The MAP_FILE.indication primitive shall use the following semantics:MAP_FILE.indication(Transaction Identifier, File Descriptor, File  Result Metadata)[END]
The MAP_FILE.indication primitive shall be passed by the FS provider to the receiving User Entity in response to an MAP_FILE.request with File Result Metadata indicating if the request was executed successfully or not.[END]
When MAP_FILE.request is successful, the File Result Metadata shall provide the File Descriptor allocated to the opened file (to logically identify it at FS level).[END]
When MAP_FILE.request is unsuccessful, the File Result Metadata shall provide the reason of the failure.[END]
The MAP_FILE.indication File Result Metadata shall report a failure if the requested File Full Path refers to an inexistent file.[END]
The MAP_FILE.indication File Result Metadata shall report a failure if the Exclusive mapping of an input interface was requested whereas this interface:-is invalid (not referring to a known interface identifier),-is not configured as RAW type,-is already mapped to another file.-[END]
The MAP_FILE.indication File Result Metadata shall report a failure if a Protocol Address mapping was requested whereas no input interface is configured with LINK_PROTOCOL type (and thus the condition could never be met).[END]
The MAP_FILE.indication File Result Metadata shall report a failure if the requested mapping applies to a Packet field (i.e. Mapping Type is either Packet Application Identifier ; Packet Packet Utilisation Standard Service ; Packet Packet Utilisation Standard Service &Subservice ; Packet Application Identifier, Packet Utilisation Standard Service & Subservice or Custom Packet Field ) whereas no input interface is configured with PACKET type.[END]
The CLOSE_FILE.request primitive shall be passed to the FS provider to request the closing of the specified file in the specified File Store and stop any autonomous storage associated to the File Descriptor.[END]
The CLOSE_FILE.request primitive shall use the following semantics:CLOSE_FILE.request(Transaction Identifier, File Descriptor)[END]
The CLOSE_FILE.request primitive shall be passed to the FS provider to request the file to be closed.[END]
Receipt of the CLOSE_FILE.request primitive shall cause the FS provider to close the specified file if opened.[END]
Closing a file that was opened with the Full File Action parameter set to “Close File & Create Next File” shall result in closing the last created file of the series.[END]
Closing a file (through the File  Descriptor obtained at openin g) shall only affect the User Entity at the origin of the request.[END]
The CLOSE_FILE.indication primitive shall be used to indicate the outcome of closing a file to the User Entity.[END]
The CLOSE_FILE.indication primitive shall use the following semantics:CLOSE_FILE.indication(Transaction Identifier, File Result Metadata)[END]
The CLOSE_FILE.indication primitive shall be passed by the FS provider to the receiving User Entity in response to a CLOSE_FILE.request with File Result Metadata indicating if the request was executed successfully or not, and the reason in case of failure.[END]
The File Descriptor of th e closed file shall become invalid as soon as the CLOSE_FILE.indication primitive is passed by the FS provider to the receiving User Entity if no error has been reported in File Result Metadata.[END]
The CLOSE_FILE.indication File Result Metadata shall report a failure if the requested File Descriptor does not corresp ond to a currently opened file.[END]
The WRITE_TO_FILE.request primitive shall be passed to the FS provider to request in-order writing of a data segment of specified length in the specified file, starting at the File Descriptor’s current position a fter its potential repositioning.[END]
The WRITE_TO_FILE.request primitive shall use the following semantics:WRITE_TO_FILE.request(Transaction Identifier , File Descriptor, Fi le Segment, File Segment Length, Absolute File Offset (optional))[END]
The WRITE_TO_FILE.request primitive shall be passed to the File Management System provider to request data segment to be written in-order to an opened file at the requested File Descriptor’s position.[END]
Receipt of the WRITE_TO_FILE.request primitive shall cause the File Management System provider to evaluate the File’s descriptor position according to the parameters and write the data segment to the specified opened file.[END]
If the evaluated File Descriptor’s position is not at the end of file (highest written position) the file’s original data shall be overwritten with the new data[END]
If the evaluated File Descriptor’s position is at the end of file (highest written position), the data shall be appended to the end of file.[END]
The File Descriptor’s current position shall be subsequently advanced through the file by the length of data effectively written.[END]
When the length of the data segment to be written (File Segment Length parameter) is bigger than the Maximum File Size minus File Descriptor’s current position, data shall be written at most up to the Maximum File Size.[END]
When an absolute file offset is given as parameter of the request, if the file was opened in Append Mode, the WRITE_TO_FIL E.request must be rejected.Rationale In Append mode the User’s entity  is not allowed to change the File’s Descriptor current position, as  it is handled automatically.[END]
When an absolute file offset is given as parameter of the request, if the position targets a memory location not associated to the file specified in this same request, the WRITE_TO_FILE.request must be rejected.[END]
If the file was opened for appending with the Packet Storage parameter selected, and the remaining space is not sufficient to store the integral data segment, no data shall be appended to the file.[END]
If the file was opened for appending and the Full File Action parameter was set to “Close File”, data not appended to the file shall be discarded, and the file closed.[END]
If the file was opened for appending and the Full File Action parameter was set to “Close File& Create Next File”, data not appended to the file shall be written to the next file (without any data loss).[END]
When data is to be written to the next file and this one already exists, it shall be opened, otherwise it shall be created prior opening.[END]
When Packet Storage parameter is selected at opening, a write operation shall be definitely rejected (no data written at all) if the File Segment Length is bigger than the Maximum File Size.[END]
When a file is opened for appending by more than one User Entity at a time (through respective File Descri ptors), respective File Descriptor’s current positions shall be synchronized between each other’s (i.e. appending a data segment to the file automatically moves the current position of other user entities).[END]
When Packet Storage parameter is selected at opening, the Maximum File Size shall be set to the current end of file (i.e. highest written position) before creating the next file.[END]
The WRITE_TO_FILE.indication primitive shall be used to indicate the outcome of writing a data segment to a file to the User Entity (and information about potential automatically performed File Management System operations).[END]
The WRITE_TO_FILE.indication primitive shall use the following semantics:WRITE_TO_FILE.indication(Transaction Identifier, File Segment Length, File Descriptor, File Closed, File Result Metadata)[END]
The WRITE_TO_FILE.indication primitive shall be passed by the FS provider to the receiving User Entity in response to a WRITE_TO_FILE.request with File Result Metadata indicating if the request was executed successfully or not.[END]
When WRITE_TO_FILE.request is successful, the File Result Metadata shall provide the length of data actually written into the file, an indication that the file was closed or not by the FS and the File Descriptor to use for next writing (relevant if creation).[END]
When WRITE_TO_FILE.request is unsuccessful, the File Result Metadata shall provide the reason of the failure.[END]
When the next file is automatically created/opened by the FS in the frame of a write operation, the returned File Segment Length shall correspond to the sum of data lengths written to both current and next file.[END]
The WRITE_TO_FILE.indication File Result Metadata shall report a failure if the requested File Descriptor does not co rrespond to a currently opened file.[END]
The WRITE_TO_FILE.indication File Result Metadata shall report a failure if therequested File Descriptor corresponds to a file that was not opened for writing.[END]
The WRITE_TO_FILE.indication File Result Metadata shall report a failure if the requested File Segment Length is negative.[END]
The returned File Descriptor pa rameter shall correspond to the file descriptor to be used for next write operation. It is either the descriptor provided in the request or the descriptor of the next file (with recursive consideration) if it was automatically created/opened by the FS in the frame of the write operation.[END]
The returned File Closed parameter shall indicate if the file (identified by the File Descriptor provided in the request) was closed or not in the frame of the write operation.[END]
The READ_FROM_FILE.request primitive shall be passed to the FS provider to request in-order reading of a data segment of specified length in the specified file, starting at the File Descriptor’s current position.[END]
The READ_FROM_FILE.request primitive shall use the following semantics:READ_FROM_FILE.request(Transaction Iden tifier, File Descri ptor, File Segment Length, Absolute File Offset (optional))[END]
The READ_FROM_FILE.request primitive shall be passed to the FS provider to request data segment to be read in-order from an opened  file at the File Descriptor’s current position.[END]
Receipt of the READ_FROM_FILE.request primitive shall cause the FS provider to evaluate the File’s descriptor position according to the parameters and to read a datasegment from the specified opened file at the evaluated File Descriptor’s position.[END]
If the File Descriptor’s position is at the end of file, no data is read.[END]
If there is less data than requested from the File Descriptor’s current position to the end of file, only the available data is read.[END]
The File Descriptor’s current position shall be subsequently advanced through the file by the length of data effectively read.[END]
When an absolute file offset is given as parameter of the request, if the position targets a memory location not associated to the file specified in this same request, the READ_FROM_FILE.request must be rejected.[END]
The READ_FROM_FILE.indication primitive shall be used to pass the data segment read from a file to the User Entity.[END]
The READ_FROM_FILE.indication primitive shall use the following semantics:READ_FROM_FILE.indication(Transaction Identifier, File Segment, File Segment Length, File Result Metadata)[END]
The READ_FROM_FILE.indication primitive shall be passed by the FS provider to the receiving User Entity in response to a READ_FROM_FILE.request with File ResultMetadata indicating if the operation was successful or not.[END]
When READ_FROM_FILE.request is successful, the service shall return the information related to the read data:-File Segment parameter contains  the data segment actually read from the file-File Segment Length parameter contains the length of the data segment read.[END]
When READ_FROM_FILE.request is unsuccessful, the File Result Metadata shallprovide the reason of the failure.[END]
The READ_FROM_FILE.indication Result Metadata shall report a failure if the requested File Descriptor do es not correspond to a current ly opened file for reading.[END]
The READ_FROM_FILE.indication Result Metadata shall report a failure if the requested File Segment Length is negative.[END]
The SEEK_FILE.request primitive shall be passed to the FS provider to request the repositioning of the File Descri ptor’s current position within a specified open file to a new position computed from a reference position and offset.[END]
The SEEK_FILE.request primitive shall use the following semantics:SEEK_FILE.request(File Transaction Identifier, File Descriptor, Relative File Offset, Whence)[END]
The SEEK_FILE.request primitive shall be passed to the FS provider to request repositioning the File Descriptor’s current position within the specified open file for the next read or write operation.[END]
Receipt of the SEEK_FILE.request primitive shall cause the File Management System provider to reposition the File Descriptor’s current position within the specified open file to the requested offset.[END]
The Relative File Offset shall be interpreted depending on the reference position (“Whence” parameter):-SEEK_Single-Event Transient means the offset is relative to the beginning of the file,-SEEK_CUR to the File Descriptor’s current position, -SEEK_END to the end of file.[END]
The offset shall be positive to move forward the specified reference position, negative to move backward and null to refe r to the reference position.[END]
The operation shall be rejected if the requested position, resulting from reference position and relative offset, is not within the range of file content (i.e. between beginning and end of file, both included).[END]
The SEEK_FILE.indication primitive shall be used to pass the outcome of repositioning the File Descriptor’s current position within the specified file to the User Entity.[END]
The SEEK_FILE.indication primitive shall use the following semantics:SEEK_FILE.indication(File Transaction Identifier, Resulting File Offset, File Result Metadata)[END]
The SEEK_FILE.indication primitive shall be passed by the FS provider to the receiving User Entity in response to a SEEK_FILE.request and File Result Metadata indicating if the request was executed successfully or not.[END]
When SEEK_FILE.request is successful, the File Result Metadata shall provide the resulting file offset –corresponding to the Fi le Descriptor’s current  position – within the file.[END]
When SEEK_FILE.request is unsuccessful, the File Result Metadata shall provide the reason of the failure.[END]
The SEEK_FILE.indication File Result Metadata shall report a failure if the requested File Descriptor does not corresp ond to a currently opened file.[END]
The SEEK_FILE.indication File Result Metadata shall report a failure if the requested reference position (“Whence ” parameter) is invalid.[END]
The SEEK_FILE.indication File Result Metadata shall report a failure if the requested File Descriptor corresponds to a file that was opened for appending data only.[END]
The SEEK_FILE.indication File Result Metadata shall report a failure if the requested position is out of file content range.[END]
The SHRINK_FILE.request primitive shall be passed to the FS provider to request truncating the content of an opened file to the requested file size.[END]
The SHRINK_FILE.request primitive shall use the following semantics:SHRINK_FILE.request(File Tr ansaction Identifier, File Descriptor, File Size)[END]
The SHRINK_FILE.request primitive shall be passed to the FS provider to request data after the requested size to be discarded from file content and the file size reduced accordingly.[END]
Receipt of the SHRINK_FILE.request primitive shall cause the FS provider to redefine the end of file position to the requested size for an opened file.[END]
Truncation shall be supported only fo r files opened for reading and writing.[END]
The operation shall be rejected if the current position of at least one User Entity having opened this file (i.e. its File Descriptor’s current position) is beyond the new requested end of file, i.e. within the part to be truncated.[END]
The SHRINK_FILE.indication primitive shall be used to pass the outcome of truncating a file to the User Entity.[END]
The SHRINK_FILE.indication primitive shall use the following semantics:SHRINK_FILE.indication(File Transaction Identifier, File Result Metadata)[END]
The SHRINK_FILE.indication primitive shall be passed by the FS provider to thereceiving User Entity in response to a SHRINK_FILE.request with Result Metadata indicating if the request was executed successfully or not.[END]
The SHRINK_FILE.indication File Result Metadata shall report a failure if the requested File Descriptor does not corresp ond to a currently open file.[END]
The SHRINK_FILE.indication File Result Metadata shall report a failure if the requested File Size is negative or bigger than the current file size.[END]
The SHRINK_FILE.indication File Result Metadata shall report a failure if the requested File Descriptor corresponds to a file that  was opened for reading-only or appending.[END]
The GET_FILE_STATUS.request primitive shall be passed to the FS provider to request the File Status of a specified File.[END]
The GET_FILE_STATUS.request primitive shall use the following semantics:GET_FILE_STATUS.request(File Transa ction Identifier, File Full Path)[END]
The GET_FILE_STATUS.request primitive shall be passed to the FS provider to request the File Status of a specific file.[END]
Receipt of the GET_FILE_STATUS.request primitive shall cause the FS provider to get information about the file corresponding to the provided File Full Path.[END]
The GET_FILE_STATUS.indication primitive shall be used to pass the File Status of the File identified File Full Path to the User Entity.[END]
The GET_FILE_STATUS.indication primitive shall use the following semantics:GET_FILE_STATUS.indication(File Transaction Identifier, File Status, File Result Metadata)[END]
The GET_FILE_STATUS.indication primitive shall be passed by the FS provider to the receiving User Entity in response to a GET_FILE_STATUS.reques tw i t h  F i l e  R e s u l t  Metadata indicating if the operation was successful or not.[END]
When GET_FILE_STATUS.request is successful, the File Status parameter shall contain all the information related to the File.[END]
When GET_FILE_STATUS.request is unsuccessful, the File Result Metadata shall provide the reason of the failure.[END]
The GET_FILE_STATUS.indication File Result Metadata shall report a failure if the requested File Full Path refers to an inexistent file.[END]
The Single-Event Transient_FILE_ATTRIBUTE.request primitive shall be passed to the FS provider to request associating an Attribute to a specified file.[END]
The Single-Event Transient_FILE_ATTRIBUTE.request primitive shall use the following semantics:Single-Event Transient_FILE_ATTRIBUTE.request(File Transaction Identifier, File Full Path, Attribute)[END]
The Single-Event Transient_FILE_ATTRIBUTE.request primitive shall be passed to the FS provider to request an attribute to be associated (created or updated) to the specified file.[END]
Receipt of the Single-Event Transient_FILE_ATTRIBUTE.request primitive shall cause the File Management System provider to first check if the attribute is already associated to the specified file. [END]
If the Attribute is not already associated to the file identified by its File Full Path, the attribute shall be created with the information provided in the Attribute parameter and associated to the file.[END]
If an attribute with same identifier is already associated to the file identified by its File Full Path, the attribute shall be updated with the information provided in the Attribute parameter.[END]
The maximum number of Attributes that can be associated per file shall be configured per File system.[END]
The Single-Event Transient_FILE_ATTRIBUTE.indication primitive shall be used to pass the outcome of associating an attribute to a file to the User Entity.[END]
The Single-Event Transient_FILE_ATTRIBUTE.indication primitive shall use the following semantics:Single-Event Transient_FILE_ATTRIBUTE.indication(File Transaction Identifier, File Result Metadata)[END]
The Single-Event Transient_FILE_ATTRIBUTE.indication primitive shall be passed by the FS provider to the receiving User Entity in response to a Single-Event Transient_FILE_ATTRIBUTE.request with File Result Metadata indicating if the operation was successful or not.[END]
When Single-Event Transient_FILE_ATTRIBUTE.request is unsuccessful, the File Result Metadata shall provide the reason of the failure.[END]
The Single-Event Transient_FILE_ATTRIBUTE.indication File Result Metadata shall report a failure if the requested File Full Path refers to an inexistent file.[END]
The Single-Event Transient_FILE_ATTRIBUTE.indication File Result Metadata shall report a failure if the Attribute Name is not already associated to the file and the maximum number of attributes per file has been reached (i.e. insertion cannot be achieved).[END]
The Single-Event Transient_FILE_ATTRIBUTE.indication Metadata shall report a failure if the requested Attribute Type is not supported.[END]
The GET_FILE_ATTRIBUTES.request primitive shall be passed to the File Management System provider to request reporting the collection of attributes currently associated to the specified file.[END]
The GET_FILE_ATTRIBUTES.request primitive shall use the following semantics:GET_FILE_ATTRIBUTES.request(Transaction Identifier, File Full Path)[END]
The GET_FILE_ATTRIBUTES.request primitive shall be passed to the FS provider to request listing the attributes (with their respective value and type) currently associated to the file identified by File Full Path.[END]
Receipt of the GET_FILE_ATTRIBUTES.request primitive shall cause the FS provider to get all the attributes currently associated to the file identified by File Full Path.[END]
The GET_FILE_ATTRIBUTES.indication primitive shall be used to pass the collection of attributes associated to a file to the User Entity.[END]
The GET_FILE_ATTRIBUTES.indication primitive shall use the following semantics:GET_FILE_ATTRIBUTES.indication(File Transaction Identifier, Attribute List, File Result Metadata)[END]
The GET_FILE_ATTRIBUTES.indication primitive shall be passed by the FS provider to the receiving User Entity in response to a GET_FILE_ATTRIBUTES.request with File Result Metadata indicating if the operation was successful or not.[END]
When GET_FILE_ATTRIBUTES.request is successful, the Attribute List parameter shall contain the complete list of attributes associated to the file.[END]
When GET_FILE_ATTRIBUTES.request is unsuccessful, the File Result Metadata shall provide the reason of the failure.[END]
The GET_FILE_ATTRIBUTES.indication File Result Metadata shall report a failure if the requested File Full Path refers to an inexistent file.[END]
The FORCE_FILE_SYNCH.request primitive shall be passed to the FS provider to request immediate synchronization of the specified file with the storage media.[END]
The FORCE_FILE_SYNCH.request primitive shall use the following semantics:FORCE_FILE_SYNCH.request(File Transaction Identifier, File Descriptor)[END]
The FORCE_FILE_SYNCH.request primitive shall be passed to the FS provider to request immediately synchronizing content and status information of an opened file to the storage media.[END]
Receipt of the FORCE_FILE_SYNCH.request primitive shall cause the FS provider to write to the storage media any modification applied to the specified opened file that have not yet been written.[END]
File synchronization to the storage media sh all be supported only for files opened for reading and writing.[END]
The FORCE_FILE_SYNCH.indication primitive shall be used to pass the outcome of synchronizing the specified file to the User Entity.[END]
The FORCE_FILE_SYNCH.indication primitive shall use the following semantics:FORCE_FILE_SYNCH.indication(File Transaction Identifier, File Result Metadata)[END]
The FORCE_FILE_SYNCH.indication primitive shall be passed by the FS provider to the receiving User Entity in response to a FORCE_FILE_SYNCH.request with File Result Metadata indicating if the request was executed successfully or not, and the reason in case of failure.[END]
The FORCE_FILE_SYNCH.indication Result Metadata shall report a failure if the requested File Desc riptor is not valid.[END]
The FORCE_FILE_SYNCH.indication Result Metadata shall report a failure if the requested File Descriptor does not correspond to a file open for writing (Read-Write access type).[END]
The GET_FILE_CHECKSUM.request primitive shall be passed to the FS provider to request computing and reporting the checksum of the specified file.[END]
The GET_FILE_CHECKSUM.request primitive shall use the following semantics:GET_FILE_CHECKSUM.request(File Transaction Identifier, File Full Path)[END]
The GET_FILE_CHECKSUM.request primitive shall be passed to the FS provider to request file checksum to be computed.[END]
Receipt of the GET_FILE_CHECKSUM.request primitive shall cause the FS provider to compute the checksum of the specified file by applying a checksum function on its content.[END]
The GET_FILE_CHECKSUM.request primitive shall be rejected if the file is currently opened with File Access Type Read-Write or Append by at least one User Entity.[END]
An in-progress checksum computation shall be immediately aborted and the User Entity notified when the file for which checksum is computed is opened with File Access Type Read-Write or Appen by any User Entity.[END]
The GET_FILE_CHECKSUM.indication primitive shall be used to pass the computed file checksum or notify the User Entity about an abort.[END]
The GET_FILE_CHECKSUM.indication primitive shall use the following semantics:GET_FILE_CHECKSUM.indication(File Transaction Identifier, File Checksum, File Result Metadata)[END]
The GET_FILE_CHECKSUM.indication primitive shall be passed by the FS provider to the receiving User Entity in response to a GET_FILE_CHECKSUM.request with File Result Metadata indicating if the request was executed successfully or not.[END]
When GET_FILE_CHECKSUM.indication primitive is successful, the service returned the result of the checksum computation in the File Checksum parameter.[END]
When GET_FILE_CHECKSUM.indication primitive is unsuccessful, the File Result Metadata shall provide the reason of the failure..[END]
The GET_FILE_CHECKSUM.indication File Result Metadata shall report a failure if the requested File Full Path refers to an inexistent file.[END]
The GET_FILE_CHECKSUM.indication File Result Metadata shall report a failure if the requested file is currently open for writing by at least one User Entity.[END]
The GET_FILE_CHECKSUM.indication File Result Metadata shall report a failure in case the file is opened for writing (by any User Entity) while the checksum is being computed.[END]
The DELETE.request primitive shall be passed to the FS provider to request deletion of an existing file in a File Store.[END]
The DELETE_FILE.request primitive shall use the following semantics:DELETE_FILE.request(File Transaction Identifier, File Full Path, Force)[END]
The DELETE_FILE.request primitive shall be passed to the FS provider to request the deletion of the specified file.[END]
Receipt of the DELETE_FILE.request primitive shall cause the FS provider to delete the specified file.[END]
The deletion shall be rejected in case the specified file is currently opened by at least one User Entity, unless Force parameter is set.[END]
The deletion shall be rejected in case a lock is applied on the specified file and the owner  of the lock is not the User Entity at the origin of the deletion request.[END]
The deletion shall be rejected in case a read-only lock is applied on the requested file.[END]
No operation shall be allowed on the file during the deletion operation.[END]
The DELETE_FILE.indication primitive shall be used to pass the outcome of deleting a file to the User Entity.[END]
The DELETE_FILE.indication primitive shall use the following semantics:DELETE_FILE.indication(Transaction Identifier, Result Metadata)[END]
The DELETE_FILE.indication primitive shall be passed by the FS provider to the receiving User Entity in response to a DELETE_FILE.request with File Result Metadata indicating if the operation was successful or not..[END]
When DELETE_FILE.request is unsuccessful, the File Result Metadata shall provide the reason of the failure.[END]
The DELETE_FILE.indication File Result Metadata shall report a failure if the requested Path refers to an inexistent file.[END]
The DELETE_FILE.indication Result Metadata shall report a failure if the file is currently open and Force parameter was not set.[END]
The DELETE_FILE.indication Result Metadata shall report a failure if a lock is applied on the file and the lock-owner is not the User Entity requesting deletion.[END]
The DELETE_FILE.indication Result Metadata shall report a failure if a read-only lock is applied on the file.[END]
The COPY_FILE.request primitive shall be passed to the FS provider to request copying an existing file from one specified directory to another specified one, either within the same File Store, between loca l File Stores, or between loca l and remote File Stores on-board.[END]
The COPY_FILE.request primitive shall use the following semantics:COPY_FILE.request(File Transaction Identifier, Source File Full Path, Destination File Full Path, Maximum File Size (optional))[END]
The COPY_FILE.request primitive shall be passed to the FS provider to request the copy of the specified existing source file to the specified destination one to be created.[END]
Receipt of the COPY_FILE.request primitive shall cause the FS provider to first create the destination file with the requested Maximum File Size (optional) or the one inherited from the source file.[END]
The attributes of the source file shall be duplicated to the destination file.[END]
The content of the source file shall be copied until end of source file.[END]
The Source File Full Path parameter shall refer to an existing file currently accessible for reading.[END]
The Source File Full Path and Destination File Full Path parameters shall not be identical.[END]
The Destination File Full Path parameter shall not refer to an already existing file.[END]
The Destination File Full Path shall only contain existing directories.[END]
When specified, the optional Maximum File Size parameter (applicable to thedestination) shall be greater than or equal to the source file’s Maximum File Size.[END]
The copy operation shall be rejected if the Maximum File Size to be applied to the destination file (either inherited from the source file or provided as parameter) is greater than the limit imposed by the destination File Store FS.[END]
The file copy operation shall be managed by a State Machine including the following states: STARTED, SUSPENDED, COMPLETED, ABORTED.[END]
The File Copy State Machine shall only authorize suspending a copy currently in STARTED state.[END]
The File Copy State Machine shall only authorize resuming a copy currently in SUSPENDED state.[END]
The Copy State Machine shall only authorize aborting a copy currently in STARTED or SUSPENDED state.[END]
The Copy State Machine shall move to ABORTED state when abort is authorized.[END]
An initiated copy operation shall immediately enter the COMPLETED state when end-of file (EOF) of the source file or the File Maximum Size is reached.[END]
The COPY_FILE.indication primitive shall be used to pass the outcome of initiating a file copy to the User Entity.[END]
The COPY_FILE.indication primitive shall use the following semantics:COPY_FILE.indication(File Transaction Identifier, File Copy Identifier, File Result Metadata)[END]
The COPY_FILE.indication primitive shall be passed by the FS provider to the receiving User Entity in response to a COPY_FILE.request with File Result Metadata indicating if the request was executed successfully or not, and the reason in case of failure.[END]
The COPY_FILE.indication File Result Metadata shall report a failure if the requested Source File Full Path refers to an inexistent file[END]
The COPY_FILE.indication File Result Metadata shall report a failure if the requested Source File Full Path is not accessible for reading (locked).[END]
The COPY_FILE.indication File Result Metadata shall report a failure if the requested Source File Full Path and Destination File Full Path are identical.[END]
The COPY_FILE.indication File Result Metadata shall report a failure if the requested Destination File Full Path refers to an already existing file.[END]
The COPY_FILE.indication File Result Metadata shall report a failure if the Destination File Full Path contains one directory that does not exist.[END]
The COPY_FILE.indication File Result Metadata shall report a failure if the requested Maximum File Size is lower than the source file one.[END]
The COPY_FILE.indication File Result Metadata shall report a failure if the threshold of maximum concurrent on-going file copy operations defined by <File Management System maximum File Copy Status> has been reached.[END]
The SUSPEND_FILE_COPY.request primitive shall be passed to the FS provider to request the immediate suspension of an on-going file copy operation.[END]
The SUSPEND_FILE_COPY.request primitive shall use the following semantics:SUSPEND_FILE_COPY.request(File Transaction Identifier, File Copy Identifier)[END]
The SUSPEND_FILE_COPY.request primitive shall be passed to the FS provider to request an on-going file copy operation to be suspended immediately.[END]
Receipt of the SUSPEND_FILE_COPY.request primitive shall cause the FS provider to suspend the identified file copy operatio n and move corresponding state machine to SUSPENDED state.[END]
The SUSPEND_FILE_COPY.indication primitive shall be used to pass the outcome of suspending a file copy to the User Entity.[END]
The SUSPEND_FILE_COPY.indication primitive shall use the following semantics:SUSPEND_FILE_COPY.indication(File Transaction Identifier, File Result Metadata)[END]
The SUSPEND_FILE_COPY.indication primitive shall be passed by the FS provider to the receiving User Entity in response to a SUSPEND_FILE_COPY.request with FileResult Metadata indicating if the request was executed successfully or not.[END]
When SUSPEND_FILE_COPY.request is unsuccessful, the File Result Metadata shall provide the reason of the failure.[END]
The SUSPEND_FILE_COPY.indication File Result Metadata shall report a failure if the requested File Copy Identifier is invalid (i.e. does not refer to an already initiated copy operation).[END]
The SUSPEND_FILE_COPY.indication Result Metadata shall report a failure if the state of the requested Copy Identifier is not STARTED.[END]
The RESUME_FILE_COPY.request primitive shall be passed to the FS provider to request the immediate resuming of a suspended file copy operation.[END]
The RESUME_FILE_COPY.request primitive shall use the following semantics:RESUME_FILE_COPY.request(File Transaction Identifier, File Copy Identifier)[END]
The RESUME_FILE_COPY.request primitive shall be passed to the FS provider to request a suspended file copy operation to be resumed immediately.[END]
Receipt of the RESUME_FILE_COPY.request primitive shall cause the FS provider to resume the identified file copy operation and move to STARTED state.[END]
The RESUME_FILE_COPY.indication primitive shall be used to pass the outcome of resuming a file copy to the User Entity.[END]
The RESUME_FILE_COPY.indication primitive shall use the following semantics:RESUME_FILE_COPY.indication(File Transaction Identifier, File Result Metadata)[END]
The RESUME_FILE_COPY.indication primitive shall be passed by the File Management System provider to the receiving User Entity in response to a RESUME_FILE_COPY.request with File Result Metadata indicating if the request was executed successfully or not.[END]
The RESUME_FILE_COPY.indication File Result Metadata shall report a failure if the requested File Copy Identifier is invalid (i.e. does not refer to an already initiated copy operation).[END]
The RESUME_FILE_COPY.indication File Result Metadata shall report a failure if the state of the requested Copy Identifier is not SUSPENDED.[END]
The ABORT_FILE_COPY.request primitive shall be passed to the FS provider to request the immediate abort of an on -going file copy operation.[END]
The ABORT_FILE_COPY.request primitive shall use the following semantics:ABORT_FILE_COPY.request(File Transaction Identifier, File Copy Identifier)[END]
The ABORT_FILE_COPY.request primitive shall be passed to the FS provider to request an on-going file copy operation to be aborted immediately.[END]
Receipt of the ABORT_FILE_COPY.request primitive shall cause the FS provider to abort the identified file copy operation and move to ABORTED state.[END]
Receipt of the ABORT_FILE_COPY.request primitive shall cause the FS provider to delete the destination.[END]
The ABORT_FILE_COPY.indication primitive shall be used to pass the outcome of aborting a file copy to the User Entity.[END]
The ABORT_FILE_COPY.indication primitive shall use the following semantics:ABORT_FILE_COPY.indication(File Transaction Identifier, File Result Metadata)[END]
The ABORT_FILE_COPY.indication primitive shall be passed by the FS provider to the receiving User Entity in response to an ABORT_FILE_COPY.request with File Result Metadata indicating if the request was executed successfully or not.[END]
When ABORT_FILE_COPY.request is unsuccessful, the File Result Metadata shall provide the reason of the failure.[END]
The ABORT_FILE_COPY.indication File Result Metadata shall report a failure if the requested File Copy Identifier is invalid (i.e. does not refer to an already initiated copy operation).[END]
The ABORT_FILE_COPY.indication File Result Metadata shall report a failure if the state of the requested File Copy Identifier is COMPLETED or ABORTED.[END]
The GET_FILE_COPY_STATUS.request primitive shall be passed to the FS provider to request reporting the current status of a file copy operation.[END]
The GET_FILE_COPY_STATUS.request primit ive shall use the following semantics:GET_FILE_COPY_STATUS.request(FileTransaction Identifier, File Copy Identifier)[END]
The GET_FILE_COPY_STATUS.request primitive shall be passed to the FS provider to request the current status of an initiated file copy to be reported.[END]
Receipt of the GET_FILE_COPY_STATUS.request primitive shall cause the FS provider to get information about the specified file copy operation.[END]
File copy statuses shall be retained for the last <File Management System maximum File Copy Status>initiated copy operations.[END]
The GET_FILE_COPY_STATUS.indication primitive shall be used to pass the status of the specified file copy to the User Entity.[END]
The GET_FILE_COPY_STATUS.indication primitive shall use the following semantics:GET_FILE_COPY_STATUS.indication(File Transaction Identifier, File Copy Status,File Result Metadata)[END]
The GET_FILE_COPY_STATUS.indication primitive shall be passed by the FS provider to the receiving User Entity in response to a GET_FILE_COPY_STATUS.request with File Result Metadata indicating if the request was executed successfully or not.[END]
The GET_FILE_COPY_STATUS.indication Result Metadata shall report a failure if the requested Copy Identifier is invalid (i.e. does not refer to an already initiated copy operation).[END]
The FILE_COPY_EVENT.indication primitive shall be used to inform the User Entity about completion or abort of an initiated file copy.[END]
The FILE_COPY_EVENT.indication primitive shall use the following semantics:FILE_COPY_EVENT.indication(File Transaction Identifier, File Copy Status)[END]
The FILE_COPY_EVENT.indication primitive shall be passed by the File Management System provider to the receiving User Entity at completion or abort of the file copy operation previously initiated with the COPY_FILE.request primitive.[END]
The MOVE_FILE.request primitive shall be passed to the FS provider to request moving an existing file from one specified directory to another specified one, either within the same File Store, between loca l File Stores, or between loca l and remote File Stores on-board.[END]
The MOVE_FILE.request primitive shall use the following semantics:MOVE_FILE.request(File Transaction Identifier, Source File Full Path, Destination File Full Path)[END]
The MOVE_FILE.request primitive shall be passed to the FS provider to request the move(and possibly the attribution of a new name) of the specified existing source file from its current directory to a destination one.[END]
Receipt of the MOVE_FILE.request primitive shall cause the FS provider to move the specified source file to the specified destination directory and set its name with the Destination File Name parameter.[END]
The data associated to a file by the FS (attributes, lock information, maximum file size) shall not be affected by the operation (e.g. if an Exclusive_Access lock is applied on the file, it shall still be locked once moved).[END]
The Source File Full Path parameter shall refer to an existing file.[END]
The Source File Full Path and Destination File Full Path shall not be identical.[END]
The Destination File Full Path parameter shall not refer to an already existing file.[END]
The Destination File Full Path shall only contain existing directories.[END]
Once moved, the file shall only exist in the destination directory.[END]
The file to be moved shall not be opened (whatever the access type) by any User Entity.[END]
The file to be moved shall not be involved in any on-going operation (move, copy, attribute modification, deletion, etc.) to start the moving.[END]
No operation shall be allowed on the file during the moving operation (i.e. once move has been initiated).[END]
The MOVE_FILE.indication primitive shall be used to pass the outcome of a file move to the User Entity.[END]
The MOVE_FILE.indication primitive shall use the following semantics:MOVE_FILE.indication(File Transaction Identifier, File Result Metadata)[END]
The MOVE_FILE.indication primitive shall be passed by the FS provider to the receiving User Entity in response to a MOVE_FILE.request with File Result Metadata indicating if the request was executed successfully or not.[END]
When MOVE_FILE.request is unsuccessful, the File Result Metadata shall provide the reason of the failure.[END]
The MOVE_FILE.indication File Result Metadata shall report a failure if the requested Source File Full Path refers to an inexistent file[END]
The MOVE_FILE.indication File Result Metadata shall report a failure if the requested file identified by Source File Full Path cannot be written (lock).[END]
The MOVE_FILE.indication File Result Metadata shall report a failure if the Source File Full Path and Destination File Full Path are identical.[END]
The MOVE_FILE.indication File Result Metadata shall report a failure if the requested Destination File Full Path refers to an already existing file.[END]
The MOVE_FILE.indication File Result Metadata shall report a failure if the Destination File Full Path contains one directory that does not exist.[END]
The MOVE_FILE.indication File Result Metadata shall report a failure if the file identified by Source File Full Path is opened by any User Entity.[END]
The MOVE_FILE.indication File Result Metadata shall report a failure if the fileidentified by Source File Full Path is involved in any on-going operation (move, copy, attribute modification, deletion, etc).[END]
The REGISTER_File Management System_EVENT.request primitive shall be passed to the FS provider to request monitoring and furthe r reporting of specified ev ents occurring within the specified directory, and optionally its sub-directories.[END]
The REGISTER_File Management System_EVENT.request primitive shall use the following semantics:REGISTER_File Management System_EVENT.request(File Transaction Identifier, Directory Full Path, Monitored Events, Recursive)[END]
The REGISTER_File Management System_EVENT.request primitive shall be passed to the FS provider to request the specified events to be reported when occurring within the specified directory, and optionally all its sub-directories.[END]
Receipt of the REGISTER_File Management System_EVENT.request primitive shall cause the File Management System provider to associate (register) the specified event( s) with the specified directory, and start monitoring of these events.[END]
The Recursive parameter extends the monitoring to all the sub-directories of the specified directory.[END]
The registration to an event for a User Entity shall be rejected if the event is already registered with the specified directory.[END]
When Recursive parameter has been set, the registration to an event for a User Entity shall be rejected if the event is already registered with one of its parent directory up to the File Management System root.[END]
When Recursive parameter has been set, the registration to an event for a User Entity shall be rejected if the event is already registered with one of its sub- directory.[END]
It shall be possible to register the events independently or grouped.[END]
When the Recursive parameter is set, it applies to all the provided Monitored Events.[END]
If the registration of one of the events in a group is not possible, then none of the events event of the group shall be registered.[END]
Deleting a directory shall cause all the events registered with it to be lost and their monitoring to stop.[END]
All the registered events on a directory shall be kept and their monitoring continue when the directory is renamed.[END]
The REGISTER_File Management System_EVENT.indication primitive shall be used to pass the outcome of registering a single or group of events with a directory to the User Entity.[END]
The REGISTER_File Management System_EVENT.indication primitive shall use the following semantics:REGISTER_File Management System_EVENT.indication(File Transaction Identifier, File Result Metadata)[END]
The REGISTER_File Management System_EVENT.indication primitive shall be passed by the FS provider to the receiving User Entity in response to a REGISTER_File Management System_EVENT.request with File Result Metadata indicating if the request was executed successfully or not.[END]
The REGISTER_File Management System_EVENT.indication Result Metadata shall report a failure if the specified Directory Full Path refers to an inexistent directory.[END]
The REGISTER_File Management System_EVENT.indication Result Metadata shall report a failure if the specified event (or any event of the group) does not correspond to supported ones.[END]
The REGISTER_File Management System_EVENT.indicationMetadata shall report a failure if the single event or group of events cannot be registered with the specified directory.[END]
The UNREGISTER_File Management System_EVENT.request primitive shall be passed to the FS provider to request stopping the monitoring and reporting of the specified event(s) within the specified directory, and optionally its sub-di rectories (based on parameters provided at registration).[END]
The UNREGISTER_File Management System_EVENT.request primitive shall use the following semantics:UNREGISTER_File Management System_EVENT.request(File Transaction Identifier, Directory Full Path, Monitored Events)[END]
The UNREGISTER_File Management System_EVENT.request primitive shall be passed to the FS provider to request the specified events to no longer be reported when occurring within the specified directory, and optionally  all its sub-directories.[END]
Receipt of the UNREGISTER_File Management System_EVENT.request  primitive shall cause the FS provider to dissociate (unregister) the specified even ts from the specified directory, and stop monitoring these events (including in subdirec tories if recursive mo nitoring was selected at registration for an event).[END]
It shall only be possible to unregister an event that is currently registered with the Directory Full Path.[END]
It shall only be possible to unregister an event from the directory it was registered with (with its new name in case renaming occurred).[END]
It shall be possible to unregister the events independently or grouped.[END]
Only the User Entity which registered an event shall be able to unregister it.[END]
If the unregistration of one of the events in a group is not possible, there shall be no event of this group unregistered.[END]
The UNREGISTER_File Management System_EVENT.indication primitive shall be used to pass the outcome of unregistering a single or group of events from a directory to the User Entity.[END]
The UNREGISTER_File Management System_EVENT.indication primitive shall use the following semantics:UNREGISTER_File Management System_EVENT.indication(File Transaction Identifier, File Result Metadata)[END]
The UNREGISTER_File Management System_EVENT.indication primitive shall be passed by the FS provider to the receiving User Entity in response to anUNREGISTER_File Management System_EVENT.request with File Result Metadata indicating if the operation was successful or not.[END]
The UNREGISTER_File Management System_EVENT.indication File Result Metadata shall report a failure if the specified Directory Full Path refers to an inexistent directory.[END]
The UNREGISTER_File Management System_EVENT.indication Result Metadata shall report a failure if the specified event (or any event of the group) does not correspond to supported ones.[END]
The UNREGISTER_File Management System_EVENT.indication Result Metadata shall report a failure if the single event or group of events cannot be unregistered from the specified directory.[END]
The File Management System_EVENT.indication primitive shall be used to report the occurrence of a registered event to the User Entity.[END]
The File Management System_EVENT.indication primitive shall use the following semantics:File Management System_EVENT.indication(File Transaction Identifier, File Management System Event)[END]
The File Management System_EVENT.indication primitive shall be passed by the File Management System provider to the receiving User Entity at each occurrence of a monitored (i.e. registered) event.[END]
The CREATE_DIR.request primitive shall be passed to the FS provider to request the creation of the specified directory in a File Store.[END]
The CREATE_DIR.request primitive shall use the following semantics:CREATE_DIR.request(File Transaction Identifier, Directory Full Path)[END]
The CREATE_DIR.request primitive shall be passed to the FS provider to request the creation of a directory.[END]
Receipt of the CREATE_DIR.request primitive shall cause the FS provider to create the specified directory.[END]
The creation shall be rejected if the Directory Full Path parameter refers to an existing directory or file.[END]
The creation shall be rejected if the Directory Full Path contains one to several inexistent directories, excluding the one to be created.[END]
The creation shall be rejected if it causes the maximum directory depth (i.e. number of sub-directories from the File Store root) to be exceeded.[END]
The CREATE_DIR.indication primitive shall be used to pass the outcome of creating a directory to the User Entity.[END]
The CREATE_DIR.indication primitive shall use the following semantics:CREATE_DIR.indication(File Transaction Identifier, Result Metadata)[END]
The CREATE_DIR.indication primitive shall be passed by the FS provider to the receiving User Entity in response to a CREATE_DIR.request.[END]
The CREATE_DIR.indication Result Metadata shall report a failure in case the Directory Full Path parameter refers to an existing directory or file.[END]
The CREATE_DIR.indication Result Metadata shall report a failure in case the Directory Full Path contains inexistent directories (except the one to be created).[END]
The CREATE_DIR.indication Result Metadata shall report a failure in case the maximum directory depth applicable to the File Store would be exceeded by creating the directory.[END]
The LIST_DIR.request primitive shall be passed to the File Management System provider to request listing the content of the specified directory.[END]
The LIST_DIR.request primitive shall use the following semantics:LIST_DIR.request(File Transaction Identifier, Directory Full Path)[END]
The LIST_DIR.request primitive shall be passed to the File Management System provider to request the content of a directory to be listed.[END]
Receipt of the LIST_DIR.request primitive shall cause the File Management System provider to list all the files and directories contained within the specified directory.[END]
The requested Directory Full Path sha ll refer to an existing directory.[END]
The LIST_DIR.indication primitive shall be used to pass the directory listing to the User Entity.[END]
The LIST_DIR.indication primitive shall use the following semantics:LIST_DIR.indication(File Transaction Iden tifier, Directory Listing, File Result Metadata)[END]
The LIST_DIR.indication primitive shall be passed by the File Management System provider to the receiving User Entity in response to a LIST_DIR.request.[END]
The LIST_DIR.indication File Result Metadata shall report a failure in case the requested Directory Full Path refers to an inexistent directory.[END]
The DELETE_DIR.request primitive shall be passed to the File Management System provider to request the deletion of an existing and empty directory in a File Store.[END]
The DELETE_DIR.request primitive shall use the following semantics:DELETE_DIR.request(File Transaction Identifier, Directory Full Path)[END]
The DELETE_DIR.request primitive shall be passed to the File Management System provider to request the deletion of the specified empty directory.[END]
Receipt of the DELETE_DIR.request primitive shall cause the File Management System provider to delete the specified directory.[END]
The operation shall be rejected if the reques ted Directory Full Path parameter refers to a non-empty directory.[END]
The DELETE_DIR.indication primitive shall be used to pass the outcome of deleting a directory to the User Entity.[END]
The DELETE_DIR.indication primitive shall use the following semantics:DELETE_DIR.indication(File Transaction Identifier, File Result Metadata)[END]
The DELETE_DIR.indication primitive shall be passed by the File Management System provider to the receiving User Entity in response to a DELETE_DIR.request.[END]
The DELETE_DIR.indication File Result Metadata shall report a failure if the requested Directory Full Path refers to an inexistent directory.[END]
The DELETE_DIR.indication Result Metadata shall report a failure if the requested Directory Full Path refers to a directory that is not empty.[END]
The RENAME_DIR.request primitive shall be passed to the File Management System provider to request the renaming of a specified di rectory in a File Store.[END]
The RENAME_DIR.request primitive shall use the following semantics:RENAME_DIR.request(File Transaction Identifier, Old Directory Full Path, New Directory Name)[END]
The RENAME_DIR.request primitive shall be passed to the File Management System provider to request the renaming of the specified directory.[END]
Receipt of the RENAME_DIR.request primitive shall cause the File Management System provider to rename the specified directory if none of the files it contains (recursively including subdirectories) is opened.[END]
The Old Directory Full Path parameter shall refer to an existing directory.[END]
The New Directory Name para meter shall contain the new name of the directory.[END]
The New Directory Name paramete r shall not refer to an alread y existing directory or file.[END]
Events registered with the directory shall re main associated and monitored after directory renaming.[END]
The RENAME_DIR.indication primitive shall be used to pass the outcome of renaming adirectory to the User Entity.[END]
The RENAME_DIR.indication primitive shall use the following semantics:RENAME_DIR.indication(File Transaction Identifier, File Result Metadata)[END]
The RENAME_DIR.indication primitive shall be passed by the File Management System provider to the receiving User Entity in response to a RENAME_DIR.request.[END]
The RENAME_DIR.indication File Result Metadata shall report a failure if the requested Old Directory Full Path refers to an inexistent directory.[END]
The RENAME_DIR.indication Result Metadata shall report a failure if the requested New Directory Name already exists within the parent  directory (i.e. in the directory containing the directory to be renamed).[END]
The RENAME_DIR.indication Result Metadata shall report a failure if the Old Directory Full Path contains a file that is current opened by any User Entity.[END]
The LOCK_FILE.request primitive shall be passed to the File Management System provider to request the locking of an existing.[END]
The LOCK_FILE.request primitive shall use the following semantics:LOCK_FILE.request(File Transaction Identifier, File Full Path, Lock Type)[END]
The LOCK_FILE.request primitive shall be passed to the File Management System provider to request the specified file to be locked (i.e. application of restrictions depending on User Entity for file opening and deletion).[END]
Receipt of the LOCK_FILE.request primitive shall cause the File Management System provider to lock the specified file with the specified lock type.[END]
The File Full Path parameter shall refer to an existing file.[END]
The requested locking shall be rejected if the file is currently open by at least one User Entity other than the one calling the lock.[END]
The requested locking shall be rejected if the file is already locked (whatever the lock owner).[END]
The LOCK_FILE.indication primitive shall be used to pass the outcome of locking a file to the User Entity.[END]
The LOCK_FILE.indication primitive shall use the following semantics:LOCK_FILE.indication(File Transaction Iden tifier, Lock Identifier, File Result Metadata)[END]
The LOCK_FILE.indication primitive shall be passed by the File Management System provider to the receiving User Entity in response to a LOCK_FILE.request.[END]
The LOCK_FILE.indication File Result Metadata shall report a failure if the requested File Full Path refers to an inexistent file.[END]
The LOCK_FILE.indication File Result Metadata shall report a failure if the requested file is currently open by at least one User Entity.[END]
The LOCK_FILE.indication File Result Metadata shall report a failure if the requested file is already locked.[END]
The UNLOCK_FILE.request primitive shall be passed to the File Management System provider to request the unlocking of a locked file in a File Store.[END]
The UNLOCK_FILE.request primitive shall use the following semantics:UNLOCK_FILE.request(File Transaction Identifier, Lock Identifier)[END]
The UNLOCK_FILE.request primitive shall be passed to the File Management System provider to request the specified file to be unlocked.[END]
Receipt of the UNLOCK_FILE.request primitive shall cause the File Management System provider to remove the lock (i.e. unlock) currently applied on the specified file.[END]
Any User Entity shall be able to unlock a locked file.[END]
The UNLOCK_FILE.indication primitive shall be used to pass the outcome of unlocking afile to the User Entity.[END]
The UNLOCK_FILE.indication primitive shall use the following semantics:UNLOCK_FILE.indication(File Transaction Identifier, File Result Metadata)[END]
The UNLOCK_FILE.indication primitive shall be passed by the File Management System provider to the receiving User Entity in response to an UNLOCK_FILE.request.[END]
The UNLOCK_FILE.indication File Result Metadata shall report a failure if the requested Lock Identifier does not refer to a valid lock (i.e. a lock currently applied to a file).[END]
The UNLOCK_FILE.indication File Result Metadata shall report a failure if the file is locked by another User Entity in any mode.[END]
The LIST_LOCKED_FILES.request primitive shall be passed to the File Management System provider to request the listing of all locked files within all the File Stores managed/accessed by the File Management System.[END]
The LIST_LOCKED_FILES.request primitive shall use the following semantics:LIST_LOCKED_FILES.request(File Transaction Identifier)[END]
The LIST_LOCKED_FILES.request primitive shall be passed to the File Management System provider to request all the locked files to be listed.[END]
Receipt of the LIST_LOCKED_FILES.request primitive shall cause the File Management System provider to list all the currently locked files (with their lock characteristics) within all the File Stores it manages/accesses.[END]
The LIST_LOCKED_FILES.indication primitive shall be used to pass the list of all locked files to the User Entity.[END]
The LIST_LOCKED_FILES.indication primitive shall use the following semantics:LIST_LOCKED_FILES.indication(File Transact ion Identifier, Locked Files List, File Result Metadata)[END]
The LIST_LOCKED_FILES.indication primitive shall be passed by the File Management System provider to the receiving User Entity in response to a LIST_LOCKED_FILES.request.[END]
The LIST_LOCKED_FILES.indication primitive shall return an empty list if no file is currently locked.[END]
The FIND_FILES.request primitive shall be passed to the FS provider to request the finding of all files matching a selection pattern against File Status (which includes the name, creation date, etc.) from a base directory which is located within any of the File Stores managed/accessed by the File Management System.[END]
The FIND_FILES.request primitive shall use the following semantics:FIND_FILES.request(File Transaction Identifier, File Selection Pattern, Base Directory Full Path, Recursive option)[END]
The FIND_FILES.request primitive shall be passed to the FS provider to request all the files matching the File Selection Pattern to be found from the base directory.[END]
Receipt of the FIND_FILES.request primitive shall cause the FS provider to find all the files matching the selection pattern against file status within the area specified (Base Directory Full Path and recu rsive option parameter). [END]
The FS provider shall perform the file search at least in the base directory and, if requested in FIND_FILES.request primitive p arameter, search recursively in the all the subdirectories. [END]
Search operation in a hierarchical File Store shall result in a search through all “branches” forming the tree-like hierarchy. [END]
The FIND_FILES.indication primitive shall be used to pass the list of files matching the File Selection Pattern to the User Entity.[END]
The FIND_FILES.indication primitive shall use the following semantics:FIND_FILES.indication(File Transaction Id entifier, Found Files List, File Result Metadata)[END]
The FIND_FILES.indication primitive shall be passed by the FS provider to the receiving User Entity in response to a FIND_FILES.request.[END]
The FIND_FILES.indication primitive shall return an empty list if no file matches the specified File Selection Pattern within at least the specified Base Directory Full Path and optionally recursively in all subdirectories (depending on the request’s parameters).[END]
The Single-Event Transient_DIR_ATTRIBUTE.request primitive shall be passed to the FS provider to request associating an Attribute to a specified directory.[END]
The Single-Event Transient_DIR_ATTRIBUTE.request primitive shall use the following semantics:Single-Event Transient_DIR_ATTRIBUTE.request(File Transaction Identifier, Directory Full Path, Attribute)[END]
The Single-Event Transient_DIR_ATTRIBUTE.request primitive shall be passed to the FS provider to request an attribute to be associated (created or updated) to the specified file.[END]
Receipt of the Single-Event Transient_DIR_ATTRIBUTE.request primitive shall cause the File Management System provider to first check if the attribute is already associated to the specified directory. [END]
If the Attribute is not already associated to the directory identified by its Directory Full Path, the attribute shall be created with the information provided in the Attribute parameter and associated to the directory.[END]
If an attribute with same identifier is already associated to the directory identified by its Directory Full Path, the attribute shall be updated with the information provided in the Attribute parameter.[END]
The maximum number of Attributes that can be associated per directory shall be configured per File system.[END]
The Single-Event Transient_DIR_ATTRIBUTE.indication primitive shall be used to pass the outcome of associating an attribute to a directory to the User Entity.[END]
The Single-Event Transient_DIR_ATTRIBUTE.indication primitive shall use the following semantics:Single-Event Transient_DIR_ATTRIBUTE.indication(File Transaction Identifier, File Result Metadata)[END]
The Single-Event Transient_DIR_ATTRIBUTE.indication primitive shall be passed by the FS provider to the receiving User Entity in response to a Single-Event Transient_DIR_ATTRIBUTE.request with File Result Metadata indicating if the operation was successful or not.[END]
When Single-Event Transient_DIR_ATTRIBUTE.request is unsuccessful, the File Result Metadata shall provide the reason of the failure.[END]
The Single-Event Transient_DIR_ATTRIBUTE.indication File Result Metadata shall report a failure if the requested Directory Full Path refers to an inexistent directory.[END]
The Single-Event Transient_DIR_ATTRIBUTE.indication File Result Metadata shall report a failure if the Attribute Name is not already associated to the directory and the maximum number of attributes per directory has been reached (i.e. insertion cannot be achieved).[END]
The Single-Event Transient_DIR_ATTRIBUTE.indication Metadata shall report a failure if the requested Attribute Type is different from the supported types.[END]
The GET_DIR_ATTRIBUTES.request primitive shall be passed to the File Management System provider to request reporting the collection of attributes currently associated to the specified directory.[END]
The GET_DIR_ATTRIBUTES.request primitive shall use the following semantics:GET_DIR_ATTRIBUTES.request(Transaction Identifier, Directory Full Path)[END]
The GET_DIR_ATTRIBUTES.request primitive shall be passed to the FS provider to request listing the attributes (with their respective value and type) currently associated to the directory identified by Directory Full Path.[END]
Receipt of the GET_DIR_ATTRIBUTES.request primitive shall cause the FS provider to get all the attributes currently associated to the directory identified by Directory Full Path.[END]
The GET_DIR_ATTRIBUTES.indication primitive shall be used to pass the collection of attributes associated to a directory to the User Entity.[END]
The GET_DIR_ATTRIBUTES.indication primitive shall use the following semantics:GET_DIR_ATTRIBUTES.indication(File Transaction Identifier, Attribute List, File Result Metadata)[END]
The GET_DIR_ATTRIBUTES.indication primitive shall be passed by the FS provider to the receiving User Entity in response to a GET_DIR_ATTRIBUTES.request with File Result Metadata indicating if the operation was successful or not.[END]
When GET_DIR_ATTRIBUTES.request is successful, the Attribute List parameter shall contain the complete list of attributes associated to the directory.[END]
When GET_DIR_ATTRIBUTES.request is unsuccessful, the File Result Metadata shall provide the reason of the failure.[END]
The GET_Block Allocable Unit_LIST.request primitive shall be passed to the File Management System provider to request reporting the list of Block Allocable Units that are used to store the data contained in the file.[END]
The GET_Block Allocable Unit_LIST.request primitive shall use the following semantics:GET_Block Allocable Unit_LIST.request(File Transaction Identifier, File Full Path)[END]
The GET_Block Allocable Unit_LIST.request primitive shall be passed to the FS provider to request the list of Block Allocable Units that are allocated to store the data of the file identified by File Full Path.[END]
Receipt of the GET_Block Allocable Unit_LIST.request primitive shall cause the FS provider to retrieve the list of Block Allocable Units associated to the file identified by File Full Path.[END]
The GET_Block Allocable Unit_LIST.indication primitive shall be used to pass the list of Block Allocable Units associated to a file to the User Entity.[END]
The GET_Block Allocable Unit_LIST.indication primitive shall use the following semantics:GET_Block Allocable Unit_LIST.indication(File Transaction Identifier, Block Allocable Unit List, File Result Metadata)[END]
The GET_Block Allocable Unit_LIST.indication primitive shall be passed by the FS provider to the receiving User Entity in response to a GET_Block Allocable Unit_LIST.request with File Result Metadata indicating if the operation was successful or not.[END]
When GET_Block Allocable Unit_LIST.request is successful, the Block Allocable Unit List parameter shall contain the complete list of Block Allocable Units associated to the file.[END]
When GET_Block Allocable Unit_LIST.request is unsuccessful, the File Result Metadata shall provide the reason of the failure.[END]
The GET_Block Allocable Unit_LIST.indication File Result Metadata shall report a failure if the requested File Full Path refers to an inexistent file.[END]
The FILE_DEFRAGMENTATION.request primitive shall be passed to the File Management System provider to request the defragmentation of the Files managed by the File Management System.[END]
The FILE_DEFRAGMENTATION.request primitive shall use the following semantics:FILE_DEFRAGMENTATION.request(File Tran saction Identifier, Store Identifier)[END]
The FILE_DEFRAGMENTATION.reque st primitive shall be passed to the FS provider to request all the files contained in the identified Store to be defragmented.[END]
Receipt of the FILE_DEFRAGMENTATION.request  primitive shall cause the FS provider to defragment the files contained in the identified Store.[END]
The FILE_DEFRAGMENTATION.indication primitive shall be used to pass the outcome of defragmenting files of a Store.[END]
The FILE_DEFRAGMENTATION.indication primitive shall use the following semantics:FILE_DEFRAGMENTATION.indication(File Transaction Identifier, File Result Metadata)[END]
The FILE_DEFRAGMENTATION.indication primitive shall be passed by the FS provider to the receiving User Entity in response to a FILE_DEFRAGMENTATION.request with File Result Metadata indicating if the operation was successful or not.[END]
When FILE_DEFRAGMENTATION.request is unsuccessful, the File Result Metadatashall provide the reason of the failure.[END]
The FILE_DEFRAGMENTATION.indication File Result Metadata shall report a failure if the identified Store does not exist.[END]
The FILE_DEFRAGMENTATION.indication File Result Metadata shall report a failure if the identified Store is not managed by a File System or does not supporte defragmentation operation.[END]
The MAP_FILE_SPLIT.request primitive shall be passed to the FS provider to request to force the next incoming data to be stored in a new file.[END]
The MAP_FILE_SPLIT.request primitive shall use the following semantics:MAP_FILE_SPLIT.request(File Transact ion Identifier, File Descriptor)[END]
The MAP_FILE_SPLIT.request primitive shall be passed to the FS provider to request the current file to be closed and next file to be opened and used to store data received on MM inputs that match the specified Mapping Criteria.[END]
Receipt of the MAP_FILE_SPLIT.request primitive shall cause the File Management System provider to close the file currently used to store the data received from the mapped interface and open the next file that will be used to store next data.[END]
The switch to the next file shall be performed without any data loss.[END]
If the Continuous Storage parameter in the Mapping Criteria is not set, the request shall be rejected.[END]
The File Management System operations (closing file and opening file) shall be performed by the File Management System provider on behalf of the user’s entity at the origin of the initialMAP_FILE_SPLIT.request.[END]
The MAP_FILE_SPLIT.indication primitive shall be used to indicate to the User Entity the outcome of the mapping segmentation.[END]
The MAP_FILE_SPLIT.indication primitive shall use the following semantics:MAP_FILE_SPLIT.indication(Transaction Identifier, File Result Metadata)[END]
The MAP_FILE_SPLIT.indication primitive shall be passed by the FS provider to the receiving User Entity in response to an MAP_FILE_SPLIT.request with File Result Metadata indicating if the request was executed successfully or not.[END]
When MAP_FILE_SPLIT.request is successful, the File Descriptor is updated to identify then newly opened file.[END]
When MAP_FILE_SPLIT.request is unsuccessful, the File Result Metadata shall provide the reason of the failure.[END]
The MAP_FILE_SPLIT.indication File Result Metadata shall report a failure if the requested File Descri ptor does not exist.[END]
The MAP_FILE_SPLIT.indication File Result Metadata shall report a failure if the File Descriptor does not refer to a continuous file mapping:[END]
The MMS shall ensure an uncorrectable bit error rate (UBER) of less than <MMSuncorrectable bit e rror rate> per cycle.[END]
The MMS shall be designed to provide a reliability of no more than <MMS failure rate> Failure in Time over the total operational lifetime including all tests and storage times on ground.[END]
The MM shall support an average data throughput <MMS average input rate>independently per physical input.[END]
The MM shall support a burst rate of <MMS burst input rate> with a maximum duration of <MM burst duration> independently per physical input.[END]
The MMS shall support writing at least <MMS data volume> data volume from hardware unit manufacturing to launch + <Mission time 2> including all test procedures.[END]
The MMS shall support a maximum data output rate <MMS maximum output rate> independently per physical output.[END]
The MMS shall support the reception of up to <MMS maximum command rate> commands (from Ground or on-boa rd application) per second.[END]
The MMS shall support the generation of its housekeeping telemetry without impacting the other operations (command processing, data storage).[END]
The MMS shall be able to handle up to < MMS simultaneous memory read or write> operations without degrad ation of performances.[END]
The MMS shall be available for receiving commands and storing data <MMS initialization time> seconds after power-on or reset.[END]
The MMS shall support a maximum of <MMS simultaneous open files> files to be open at a time.[END]
The MMS shall implement error detection mechanisms capable of detecting and reporting errors according to the re quired performance levels.[END]
The MM shall provide the capability to perform a non-destructive self-test of all storagemedia.[END]
The MMS shall maintain a list of all the errors affecting the storage media in a non-volatile memory.[END]
The MM shall support maintaining at least two copies of the MMS Software in non-volatile memory.[END]
The version of the MMS Software to be used shall be defined by a flag (HW or SW), and selectable by telecommand.[END]
The MMS shall support autonomous exclusion of Smallest Allocable Unit detected as definitively faulty or anticipated to be faulty in the future from the MMS storage media capacity.[END]
When excluding an anticipated to be faulty Smallest Allocable Unit, the MMS shall support moving the data it contains to another location.[END]
When isolating a Smallest Allocable Unit, the MMS shall indicate it to the Fault isolation mechanism which will identify the potential affected area and handle the situation accordingly with support of corresponding Data Management System.[END]
The MMS shall be able to stop the Data Management System without loss of data already stored.[END]
The MMS shall maintain the status of the Data Management System whether it is available or not.[END]
The MMS shall make available the status of the Data Management System to any User Entity.[END]
The On-Board Computer shall be able to start the Data Management System and select whether:- the context shall be recovered or - the default initial configuration shall be used.[END]
When performing memory administration operation, the MMS shall store the related trace (parameters, address, size and identifier) in a non-volatile memory. Memory administration operations are:xSmallest Allocable Unit to Block Allocable Unit allocationxSmallest Allocable Unit isolationxBlock Allocable Unit creation, modification and deletion,xSTORE creation, modification and deletion xFile allocation table (or equivalent) modification.[END]
When a reconfiguration occurs or in any case making the File Management System unavailable, the File Status shall be maintained in their state. [END]
The MMS shall be able to provide a User Entity a unique identifier.[END]
The MMS Transaction Identifier shall be a value, assigned by the invoking User Entity, which is subsequently used to associate indication primitives with the causal request primitives.[END]
The MMS Result Metadata parameter shall be used to provide information generated by the MMS provider to the User Entity regarding result of the execution of a request.[END]
The User Entity Identifier parameter shall uniquely identify a User Entity.[END]
The GET_USER_ENTITY_IDENTIFIER.request primitive shall be passed to the MMS provider to request its User Entity identifier.[END]
The GET_USER_ENTITY_IDENTIFIER.request primitive shall use the following semantics:GET_USER_ENTITY_IDENTIFIER.request(MMS Transaction Identifier)[END]
The GET_USER_ENTITY_IDENTIFIER.request primitive shall be passed to the MMS provider to request a unique User Entity identifier to be used.[END]
Receipt of the GET_USER_ENTITY_IDENTIFIER.request primitive shall cause the MMS provider to generate a unique identifier that can be used by the User Entity to identify itself to the MMS.[END]
The GET_USER_ENTITY_IDENTIFIER.indication primitive shall be used to return the User Entity Identifier.[END]
The GET_USER_ENTITY_IDENTIFIER.indication primitive shall use the following semantics:GET_USER_ENTITY_IDENTIFIER.indication(MMS Transaction Identifier, User Entity Identifier, MMS Result Metadata)[END]
The GET_USER_ENTITY_IDENTIFIER.indication primitive shall be passed by the MMSprovider to the receiving User Entity in response to a GET_USER_ENTITY_IDENTIFIER.request with MMS Result Metadata indicating if the request was executed successfully or not.[END]
When GET_USER_ENTITY_IDENTIFIER.indication primitive is successful, the service returned the unique identifier in the User Entity Identifier parameter.[END]
When GET_USER_ENTITY_IDENTIFIER.indication primitive is unsuccessful, the MMSResult Metadata shall provide the reason of the failure.[END]