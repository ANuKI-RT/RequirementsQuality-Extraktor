,               The syntax and semantic of MicroPython is de fined as a subset of Python 3.4, with some restrictions.  The language subset and restrictions are el aborated in the following requirements. Note that the standard library of Python 3.4 is  mostly excluded from the presen t requirements; the small subset of modules that are covered, at least partiallyare specified, in other requirements (see below).    
   MicroPython shall support the following buil t-in types, as defined in Python 3.4: bool int float str object super type  The mapping from Python types to ECSS-E-ST01C' s simple types is as follows: bool  Boolean int Integer, Unsigned Integer, bit string, octet string  float   Real These can be used also as functions for type -casting constructs. The “value type data types” can be ma de using Python inheritance, with object  and super  types.  Note that, compared to ECSS -E-ST01C, engineer ing units are not covered and syntax may differ . Note also that the following simple types are not covered: the types for packet fields identified in [AD01] (i.e. the PUS), absolute and rela tive time (Python module datetime)enumerated types  and enumerated set (Python module enum).               
   MicroPython shall support the following buil t-in types, as defined in Python 3.4: bytearray bytes tuple dict list  Note that a record (see [AD01]) can be represented by the dict  type (dictionary), which is the approach taken for user -defined classes. Note however that unlike usual records, dictionary can add/remove fields at runtime; the same applies for classes since the __slots__   class attribute is not supported. This  peculiarity can be avoided by using namedtuple   to represent records : the namedtuple   type is closest to the concept of record  because it defines fi xed fields with fixed names (s ee 110).    
  MicroPython shall support the following buil t-in types, as defined in Python 3.4: filter memoryview set range reversed zip enumerate map  Note that the afore-mentioned types are no t required by [AD01]. Note also that the following types present in [RD02] have been left out: propertycomplex, frozenset .   
  MicroPython shall support the following built- in functions, as defined in Python 3.4: abs(x) -- absolute value  all(iterable) -- True if all values in iterable are True  any(iterable) -- True if any values in iterable are True  bin(x) -- format number in binary representation  chr(x) -- character corresponding to value x dir([obj]) -- list of attributes in object divmod(x, y) -- a tuple with division and modulus  globals() -- dictionary of global objects  hasattr(obj, attr) -- check for an attribute  hash(obj) -- hash value of an object  hex(x) -- format number in hexadecimal representation  id(obj) -- unique number corresponding to object  isinstance(obj, cls) -- True if obj is instance of cls  iter(obj) -- create an iterator from the given object  len(iterable) -- number of elements in iterable max(x, ...) -- maximum of all arguments  min(x, ...) -- minimum of all arguments  next(iterator) -- get next item from iterator  oct(x) -- format number in octal representation  pow(x, y[, mod]) -- power of arguments  print(...) -- print all arguments  round(x[, digits]) -- round a float  sorted(iterable[, key][, reverse]) -- sort an iterable             sum(iterable[, start]) -- sum all values in an iterable   Note that the following function s present in [RD02] have been left out: callable getattrattrsetattrreprissubclassordlocals  
  MicroPython shall support the following built-in ex ception class hierarchy, as defined in Python 3.4: BaseException    GeneratorExit    KeyboardInterrupt    SystemExit    Exception      ArithmeticError        OverflowError        ZeroDivisionError      AssertionError      AttributeError      EOFError      ImportError      LookupError        IndexError        KeyError      MemoryError      NameError      OSError      RuntimeError        NotImplementedError      StopIteration      SyntaxError        IndentationError      TypeError      ValueError       UnicodeError    
  MicroPython shall support the following classes, as defined in Python 3.4: classmethod  staticmethod  Note that the following class present in [RD02] have been left out : Ellipsis              
T  MicroPython shall support the following functions from the module gc, as defined in Python 3.4: gc.collect()  gc.disable()  gc.enable()  gc.isenabled()  gc.mem_free()  gc.mem_alloc()     
  MicroPython shall support the following function from the module sysas defined in Python 3.4: sys.exit([code])  If code  argument is missing, then the default valueshall be taken . Upon completion with sys.exita SystemExit exception shall be raised an d the C function starting the Virtual Machine execution shall return the given code  value bitwise ORed with 128.  Note that the following constants present in [RD02] have been left out : sys.byteorder, sys.implementation, sys.maxsize, sys.platform, sys.version, sys.version_info . The rationale is that the dependen cies with the target platform are already taken into account by the Mic roPython cross-compiler (hence, not by the MicroPython source script) .  
  MicroPython shall support the following function from the module arrayas defined in Python 3.4: array.array(typecode[, initialiser])     
  MicroPython shall support the following functions from the module ucollectionsas defined in Python 3.4 under the name collections : ucollections.namedtuple  Note that namedtuple  is the Python type closer to the concept of "record" (see comments in             030).  The OrderedDict  function present in [RD02] has been left out.   
  MicroPython shall support the following functions from the module mathas defined in Python 3.4: e acos(x) frexp(x)  pi asin(x) ldexp(x, i)  sqrt(x) atan(x) modf(x)  pow(x, y) atan2(y, x) isfinite(x)  exp(x) ceil(x) isinf(x)  log(x[, base]) copysign(x, y) isnan(x)  cos(x) fabs(x) trunc(x)  sin(x) floor(x) radians(x)  tan(x) fmod(x, y) degrees(x)     
  MicroPython shall support the following functions from the module structas defined in Python 3.4: calcsize(fmt)  pack(fmt, ...)  pack_into(fmt, buf, offset, ...)  unpack(fmt, buf)  unpack_from(fmt, buf, offset)      
  MicroPython shall support the following functions from the module binasciias defined in Python 3.4: hexlify(data)  unhexlify(hexstr)  a_base64(string) b_base64(data)   This module is used to convert between  binary data and various ASCII encodings.                 
2, MicroPython shall provide the module micropythonwith the following functions: micropython.stack_use()  Return the current amount of C stack that is used.  micropython.pystack_use()  Return the current amount of Python stack that is used. This function is available only if the Virtual Machine has been compiled in a configurat ion which uses a separate stack for Python function calls.  micropython.heap_lock()  Lock the heap so that memor y cannot be allocated. Any allocation that is attempted after calling this function will  raise a MemoryError exception.  micropython.heap_unlock()  Unlock the heap. The function heap_lock()  should be called after initializat ion so that heap use is totally deterministic ( i.e. does not change).  The mem_info()  and qstr_info()  functions present in [RD02] have been left out .    
,      ,   ,           5 5 MicroPython shall allow for using custom modules developed in C. Dedicated MicroPython modules can then be developed to access, in a safe way, the services and resources of OS and target platfor m.    
,              The MicroPython Virtual Machine shall provide a C function to  start execution of MicroPython bytecode at a given address in memory. When the bytecode ex ecution ends, the function shall return the return code (0 if no error code is specified) . The MicroPython Virtual Machine shall not modify or remove the bytecode.   
  If the MicroPython Virtual Machine cannot allocate required memory during execution, it shall stop and it shall raise  a specific exception .   
  ,5  If the MicroPython Virtual Machine catches an exception du ring execution (uncaught by the MicroPython bytecode itself), it shall stopreturn a specific error code  and provide a means to retrieve the line number in the MicroPython source code where the exception was raised . The Python execution mode l handles any error occurring in as an exception. Such exception can be caught and treated by the MicroPython procedure itself. If  not, the exception is propag ated to the Virtual Machine, which shall then halt.   
   ,  The MicroPython language shall support object-orientation, as defined in Python 3.4 The object-orientation allows using the" templa te method" design pattern to enforce a common structure and execution logic.  The idea is to define once for all an abstract class with methods for the different bodies ( e.g. precondition, main, confirmation, contingency);  these methods have a default empty implementation ; the actual class inherits the abstract one and overloads the required methods.     
             MicroPython cross-compiler shall be provided . It shall generate a bytecode file, having .mpy  extension, from a given MicroPython sc ript that is syntactically valid. The words "syntactically vali d" mean that the script conforms to the grammar of MicroPython. As per the Python language  itself, there is n o further static check, like availability of referred names (variable, function, meth od, class, module, etc).  The MicroPython cross -compiler is not formally qualified; it is not part of the flight code and it is not required to comply with CAT -B software.    
  The Software Development Environment shall provide a tool to calculate for a given bytecode, the ISO checksum, as defined in Annex A.2 of [RD03]. The tool shall take a .mpy  file as input and produce a .bin  file with the content of the .mpy  file appended with the ISO checksum (2 bytes).     
 If the given script has an invalid syntax, the MicroPython cross-compiler shall report an error, indicating the first invalid li ne. No bytecode file shall be generated in such case.    
  After being loaded in memory, the byte code ge nerated by the MicroPython cross-compiler shall be executable by the MicroPython Virtual Machine, with the semantic specified by the MicroPython source script. See 190   
     The MicroPython Software Development Environment shall provide a preprocessing tool called "Import Expander". The Import Expander shall take a given Micr oPython script in input and it shall generate a semantically equivalent MicroPython script by replacing import statements by the content of the corresponding MicroPython source files, provided  that these modules are not C extensions. This process shall be recursive, in case the imported  modules themselves contain import statements.  One of the goal of the Import Ex pander is to be able to produce one single bytecode for one given             MicroPython procedure, whatever the imported mo dules in this procedure. This is meant to simplify the tran sport and loading of bytecode in the MicroPython Virtual Machine.  Note that this preprocessing is formally required because the lo ading and registering of module bytecode  in the Virtual Machine is not in the scope of the present SRS.   
     The Import Expander shall be able to treat both flavours of MicroPython import:   from m1 import … or   import m2, m3 If the as keyword is found, in any of these two flavours, then the tool shall report an error telling that it cannot handle such case.  For the first flavour, in order to limit comple xity, it shall be accepted to treat    from m1 import a, b  like   from m1 import * Notes:  Import using p ackage notation  are not treated  (e.g. import m1.m2.m3  is not expanded). The use of asterisk may cause unwanted variable re binding in case of name collision. This can be limited by using the smart ex pansion feature described in 520. Independently of the tool described here, the use of the from import  flavour is generally not recommended in Python scriptsfor the sake of maintainability . If advanced features of Python are used (e.g. introspection, locals/g lobals  dictionaries, etc), side-effects may be observed due to the "class embedding" trick.  In case of un caught exception (see  190), th e developer shall take care that the reported line number is given in  the expanded source code file.    
     The Import Expander shall detect when an im port statement refers to a module already imported, whether directly or through cascaded imports; in such situation, it shall apply the following rules: 1. If import m is found in scope S2 while import m has already been encountered in scope S1, then x if S2 = S1, then the latest import statement shall be skipped,             x if S2 ≠ S1, then the import statement in S2 shall be replaced by an assignment that creates an alias so that the objects of m can be referred also using S2 scope. 2. If from m import … is found in scope S2 while from m import … has a lready been encountered in scope S1, then x if S2 = S1, then the latest import statement shall be skipped, x if S2 ≠ S1, then the new tool shall report an error telling that it cannot handle such case. 3. If import m  and from m import …  flavours are mixed at different places for the same given module m (whatever their scopes), then the tool shall report an error telling that it cannot handle such case.  These rules are meant to mimic as close ly as possible the native  import mechanism of Python, so to avoid side effects due to static expansion.  In particular, a given modu le should not be expanded twice, wherever it is imported ; therefore, an object that is im ported at different places cannot be created twice  (this is particularly important for mutabl e object). The most complex cases, which usually reveal bad programming  practices, are not suppor ted and reported as such.    
      The Import Expander shall be able to do "smart expansion": for a given list of modules, it shall analyse the importing MicroPython procedure and only copy the subset of assignments of variables that are actually used in this procedure. The rationale is to have a MicroPython module containi ng all symbols defined in a databaseas a set of MicroPython assignments  (this should be automated by a dedicated tool). For example, the following script could be produced from the engineering data repository:   # sdb.py   camera_1_id =  camera_2_id =  … MicroPython procedure can then import this file and use the required subset of variables. Since this imported module is arbitrarily large, it is sensible to requ ire that the Import Expander copies only t he required subset of assignments.  This solution assumes that there are no interdependencies between variables in the imported file . For example, the assignment    # sdb.py   …   camera_1_controller_id = camera_1_id * 100 +would fail if camera_1_id   is not referred in the importing module.his is why such mechanism is not required by default for all imported modules: only  the modules declared by the user are assumed to be simple assignments and can then be expanded without mistakes.              
 E-100 The Import Expander shall be able to report all the names that have been retained by the "smart expansion". This allows for getting the list names of variables imported from a database and actually used by the  procedure.   
I  The Software Development Environment shall provide a static analysis tool to display violation to coding standard for a given MicroPython procedure and possibly detect some errors. Note that some displays the code quality metrics.  
  The Software Development Environment shall provide a static analysis tool to display the call tree of a given MicroPython procedure.    
  MicroPython shall provide the module memwith the following functions: mem.read_u32(addr)  Return the 32-bit value at the given addr  address. addr  must be word aligned.  mem.write_u32(addr, value) Write value  to the given addr  address. addr  must be word aligned. Returns None .  mem.read_buf(addr, buf) Read a memory region starting at the address addr  into the given buffer. buf  must be a bytearray  or an array  and its length specifies the length of the read. The read is done using 32-bit words so addr  must be word aligned and the length of buf  must be a multiple of 4. Returns None .  mem.write_buf(addr, buf) Write the given buffer to the memory address addr . buf  must be a bytearray  or an array  and its length specifies the length of the write. The write is done using-bit words so addr  must be word aligned and the length of buf  must be a multiple of 4. Returns None .                 
  MicroPython shall provide the module rtemswith the following function: rtems.script_id()  Return an integer being the identifier of  the Virtual Machine instance that this script is running in. The first Virtual Machine has an identifier of 0.  and the following objects (integer constants):   DEFAULT_ATTRIBUTES, WAIT, NO_WAIT, SEARCH_ALL_NODES, SEARCH_OTHER_NODES, SEARCH_LOCAL_NODE.  with same meaning as defined in Real-Time Executive for Multiprocessor Systems.  The handling of errors that may be repo rted by the underlying Real-Time Executive for Multiprocessor Systems functions is specified in 
.   
  MicroPython shall provide the module rtems.queue  for creating and using message queues. It shall provide the following functions: rtems.queue.create(name, count, max_size, attr=rtems.DEFAULT_ATTRIBUTES)  Create a new Real-Time Executive for Multiprocessor Systems queue and return a queue object that can be used to send and receive messages on the queue. The name  argument must be a string of four characters long. count  is the maximum number of messages the queue can hold before getting full. max_size  is the maximum size of a message, in bytes. The attr  argument specifies the attributes of the queue and defaults to rtems.DEFAULT_ATTRIBUTES . Corresponding C function: rtems message queue create(). Note: this function uses the heap to create the queue object.  rtems.queue.ident(name, node=rtems.SEARCH_ALL_NODES) Access an existing Real-Time Executive for Multiprocessor Systems queu e and returns a queue object corresponding to that queue. The name  argument must be a string of four characters long. node  speci fies the node to search for the queue on and can be one of rtems.SEARCH_ALL_NODESrtems.SEARCH_OTHER_NODES  or rtems.SEARCH_LOCAL_NODE . Corresponding C function: rtems message queue ident(). Note: this function uses the heap to create the queue object.              The above functions return a queue  object which has the following methods to access the underlying Real-Time Executive for Multiprocessor Systems queue.  queue.delete() Deletes the queue. Returns None . Corresponding C function: rtems message queue delete().  queue.send(buf, option=rtems.NO_WAIT, timeout=0) Send a message on the queue. buf  must be a str  object, bytes  object, bytearray  or array . options  is one of rtems.WAIT  or rtems.NO_WAIT . If rtems.WAIT  is specified as the optionthen the timeout  argument specifies how long to wait (in ticks), with a negative or zero value meaning to wait forever. The default is to not wait. Returns None . Corresponding C function: rtems message queue send(). Note: the blocking behaviour using rtems.WAIT  is a MicroPython extension to the Real-Time Executive for Multiprocessor Systems API. If this option is given then the function rtems_message_queue_send  will continue to be called while it returns Real-Time Executive for Multiprocessor Systems_TOO_MANY  (meaning that the queue is full).  queue.urgent(buf, option=rtems.NO_WAIT, timeout=0) This method has the same arguments and behaviour as queue.send  except that the message has urgent priority. Corresponding C function: rt ems message queue urgent().  queue.broadcast(buf) Broadcasts a message on t he queue. buf must be a str  object, bytes  object, bytearray  or array . Returns number of tasks that received the message.  queue.receive(buf, option=rtems.WAIT, timeout=0)  Receive a message from the queue and st ore it in the given buffer. The buffer argument buf must be a bytearray  or array . options  is one of rtems.WAIT  or rtems.NO_WAIT . If rtems.WAIT  is specified as the option then the timeout argument specifi es how long to wait (in ticks), with  a negative or zero value meaning to wait forever. The default is to wait forever. This method returns the number of bytes written into buf . Corresponding C function: rtems message queue receive(). Note: buf  must have enough room for the message.  queue.flush() This method flushes the message queue, and returns the count. Corresponding C function: rtems message queue flush().  queue.get_number_pending() This method returns the number of messages pending on the queue. Corresponding C function: rtems message queue get number pending().  The handling of errors that may be repo rted by the underlying Real-Time Executive for Multiprocessor Systems functions is specified in 
.               
  MicroPython shall provide the module rtems.sem  for creating and accessing Real-Time Executive for Multiprocessor Systems semaphores. It shall provide the following functions: rtems.sem.create(name, count=1, attr=rtems.DEFAULT_ATTRIBUTES, prio=0)  Create a new Real-Time Executive for Multiprocessor Systems semaphore and returns a semaphore object that can be used to control concurrent access to a resource. The name  argument must be a string of four characters long. count  is the number of units that the initial semaphore holds (defaults to one unit). The attr  argument specifies the attributes of the semaphore and defaults to rtems.DEFAULT_ATTRIBUTES . prio  is the priority ceiling of the semaphore. Corresponding C function: rtems semaphore create(). Note: this function uses the heap to create the semaphore object.  rtems.sem.ident(name, node=rtems.SEARCH ALL NODES)  This function accesses an existing Real-Time Executive for Multiprocessor Systems semaphore and returns a semaphore object corresponding to that semaphore. The na me argument must be a string of four characters long. node  specifi es the node to search for the semaphore on, and can be one of rtems.SEARCH_ALL_NODESrtems.SEARCH_OTHER_NODES  or rtems.SEARCH_LOCAL_NODE . Corresponding C function: rtems semaphore ident(). Note: this function uses the heap to create the semaphore object.  The above functions return a semaphore object ( sem ) which has the following methods to access the underlying Real-Time Executive for Multiprocessor Systems semaphore.  sem.delete()  Deletes the semaphore. Returns None . Corresponding C function: rtems semaphore delete().  sem.obtain(option=rtems.WAIT, timeout=0) Obtains the semaphore. If rtems.WAIT  is specified as the option then the timeout  argument specifies how long to wait (in ticks), with a negative or zero value meaning to wait forever. The default is to wait forever. Returns None . Corresponding C function: rtems semaphore obtain().  sem.release() Releases the semaphore. Returns None . Corresponding C function: rtems semaphore release().  sem.flush() Flushes the semaphore. Returns None . Corresponding C function: rtems semaphore flush().  The handling of errors that may be reported by the underlying Real-Time Executive for Multiprocessor Systems functions is specified in             660.   
  MicroPython shall provide the module rtems.taskwith the following functions: task.wake_when((year, month, day, hour, minute, second))  Take a tuple ofintegers specifying a da te and time. The script will sleep until that point in time. Returns None. Corresponding C function: rtems task wake when().  task.wake_after(ticks) Take an integer being a number of ticks, and pauses the script for that duration. Returns None . Corresponding C function: rt ems task wake after(). Note: it is recommended to use time.sleep(sec)  instead because that is the standard Python way of pausing execution.  task.get_note(note_id) Take an integer and returns an (unsigne d) integer which is the value of the RT EMS notepad with the given identifier  (betweenandinclusive). Corresponding C function: rtems task get note().  task.set_note(note_id, note_val) Take an integer for the notepad identifier, and an integer value, and stores the latter in the Real-Time Executive for Multiprocessor Systems notepad. The note_val  argument is truncated tobits. Returns None . Corresponding C function: rtems task set note(). Note: notepadandare used by the MicroPython Virtual Machine manager.  The handling of errors that may be repo rted by the underlying Real-Time Executive for Multiprocessor Systems functions is specified in 
.   
  MicroPython shall provide the module timewith the following functions: time.localtime()  Return a 6-tuple containing: (year, month, mday, hour, minute, second) . month  is in the range 12 (inclusive), mday  is in 11, hour  is in 03, minute  is in 09 and second  is in 09.  time.localtime_into(lst)  Store into the given list the following items: (year, month, mday, hour, minute, second) . The range of these values is the same as in the time.localtime  function.  time.time()              Return the number of seconds since the Epoch, as a  float. Has sub-second precision.  time.sleep(seconds)  Sleep for the given number of seconds. seconds  can be a  float to sleep for a fractional number of seconds.  Note: the time.localtime_into   function shall be used in place of time.localtime   if the heap is locked (see 150). The handling of errors that may be repo rted by the underlying Real-Time Executive for Multiprocessor Systems functions is specified in 
.    
  Each function provided by the rtems  module and its sub-modules (see above) shall check the returned status code of the underlying RTEM S C functions. If this return code is not Real-Time Executive for Multiprocessor Systems_SUCCESSFULthen the function shall raise a Python OSError  exception with a single argument, which is the string corresponding to the rtems_status_code .    
           ,   ,      Software Development Environment (Software Development Environment) shall be provided for developing MicroPython procedure.  This Software Development Environment shall provide functions for edit ion, syntax checking, code completion, execution and debugging. For these functions,  the MicroPython scri pt under development shall be assimilated to a Python 3.4 script.              The Software Development Environment should be a standard Software Development Environment as PyDev or PyCharm. Since MicroPython is in essence a subset of Python 3.4it is expected  x that the edition, syntax check works as expected, x that the code completion works as expected for all standard Python 3.4 standard modules / builtin functions ported  in MicroPython. For all C modules developed specifically for MicroPython or for interfacing with an OS or an On-Board Softwarethe developer should implement stub modules in MicroPython. Under the assumption that all required modules are stubbed, the Software Development Environment can execute/debug the MicroPython script using the host Python 3.4 interpreter . This execution is however not fully representative of an execution on the MicroPython Virtual Machine because:  x the C modules are stubbed; x MicroPython Virtual Machine implementation may differ from Python 3.4 (offline compilation, numerical accuracy,...); x the memory is expected to be more limited in MicroP ython Virtual Machine than in host Python 3.4 The memory management is different also; x imported modules could be have been expanded inline (see 3.2).   
  The MicroPython Software Development Environment shall provide the user a simple means to call the MicroPython cross-compiler on any MicroPython procedure to generate the associated bytecode file (extension .mpy). The messages output by the cross-compiler shall be visible in the Software Development Environment. The error reporting of MicroPython cross-compiler is helpful to check that the written script conforms to MicroPython language, which is  stricter than a Python 3.4 (e.g. unavailability of some builtin functions, disabling of complex numbers, etc.) .  
  If the Software Development Environment is configured to do so, the Import Expander shall be called automatically before calling the cross-compiler (preprocessing of source code). The messages output by the Import Expander shall be visible in the Software Development Environment. The error reporting of Import Expander is helpful to check that the written script conforms to the specific limitations of “import”which are stricter than a Py thon 3.4 (e.g. import rules).   
  The Software Development Environment shall provide a simple means to call the ISO checksum tool in order to produce the .bin  file for a given .mpy  file.               
  The Software Development Environment shall provide a simple means to load and execute a given bytecode file on a given LEON2 target.   
  The Virtual Machine test suite shall be automated. The objective is to be able to re -run the Virtual Machine test suite easi ly on a different target.  
   The MicroPython Virtual Machine executable code shall be designed to have a minimal size, which shall not exceed 200 kbytes.  The MicroPython Virtual Machine  executable can be stored on RAM or, preferably, on ROM. Memory efficiency  of the MicroPython Virtual Machine  is important because it is a limited resource in a spacecraft and because it is used also by On-Board Software . Possible solutions can be found in [RD01] (chapter 4).  
   The MicroPython cross-compiler shall be designed to produce a bytecode with a minimal size.  This requirement impacts also the design  and performance of MicroPython Virtual Machine.  Possible solutions can be found in [RD01] (chapter 4).  
               The MicroPython Virtual Machine shall be designed to execut e the bytecode using a good trade-off between memory consumption and execution time. For this choice, the minimisation of memory consumption should be prioritized. See rationale in MPVirtual Machine-PERF10. Possible solutions can be found in [RD01] (chapter 4).   
   The MicroPython cross-compiler source code an d/or compile chain shall contain configuration parameters to account for constraints of specif ic hardware target (e.g. ROM / RAM size) or for selecting a specific trade-off for a given target. See rationale in MPVirtual Machine-PERF10.   
   The MicroPython Virtual Machine source code and/or compile chain shall contain configuration parameters to account for constraints of specific hardware target (e.g. ROM / RAM size) or for selecting a specific trade-off for a given target. See rationale in MPVirtual Machine-PERF10. 
  The MicroPython environment is made up of a Software Development Environment (development of MicroPython script), a cross-compiler (production of bytecode from MicroPython script), a Virtual Machine (execution of the bytecode).   
  In the C source code of MicroPython cross-compiler and Virtual Machine, any language feature out of scope of the requirements defined in the present document shall be disabled by C preprocessor directives. The goal is here to avoid branching in the configur ation of MicroPython. The rationale is to be able to integrate bug fixes an d evolutions ma de on the development trunk.              
  The MicroPython Virtual Machine and compile chain shall support two configurations for MicroPython object representation: 1.bits model   ̶  floating-point numbers require heap allocation, 2.bits model “NaN Boxing”   ̶  floating numbers do not require heap allocation. Both configurations are subject to the qualificatio n. See description and rationale in section 5.5.1 of [RD01].   
  The MicroPython Virtual Machine and compile chain shall allow building MicroPython Virtual Machine without support of memtime  and rtems  modules/submodules (see 
,     
,  660). This option is not part of the qualification, which covers a configuration with all the afore-mentioned modules included.   
  The MicroPython Virtual Machine shall run on LEON on top of Edisoft Real-Time Executive for Multiprocessor Systems 4.8. The development is meant to be compatible also with Edisoft Real-Time Executive for Multiprocessor Systems 4.10 and 4.11, as well as LEON 3.  This portability is however ou t of scope of the present SRS.  
  The MicroPython Software Development Environment, including the Import Expa nder, shall run on a Unix system compatible with Python 3.4               
  The MicroPython Virtual Machine build toolchain, the MicroP ython cross-compiler and its build toolchain shall run on a Unix system, with the following so ftware components installed: Python 3.4, gcc, cross-compiler for SPARC V8 and Edisoft Real-Time Executive for Multiprocessor Systems 4.8. The chosen Unix version should th en be compatible with the afore-mentioned software components.   
   The MicroPython Virtual Machine shall be qualified with requirements of ECSS CAT-B, as defined in [AD02] and [AD03].    
 The MicroPython Virtual Machine shall raise an exception in case  it is no more possible to allocate memory on the heap.   
 The MicroPython Virtual Machine shall raise an exception in case  it is no more possible to allocate memory on the stack.              
   The MicroPython Virtual Machine source, configuration, tool chai n and test bench files shall be maintained in configuration control.   
