The application conﬁguration option shall disable the system initialization of ﬁlesystems.[END]
The application conﬁguration option shall disable the system initialization of the Clock Driver.[END]
The application conﬁguration option shall enable the initialization of the Clock Driver duringsystem initialization.[END]
Where CONFIGURE_DISABLE_BSP_SETTINGS is not deﬁned by the application, whereBSP_INITIAL_EXTENSION is deﬁned by the BSP, when the application conﬁguration is initial-ized, the extension set deﬁned by BSP_INITIAL_EXTENSION shall be registered in the initialextension sets.[END]
Where CONFIGURE_DISABLE_BSP_SETTINGS is not deﬁned by the application, whereCONFIGURE_BSP_PREREQUISITE_DRIVERS is deﬁned by the BSP, when the applica-tion conﬁguration is initialized, the device driver entry points deﬁned by CONFIG-URE_BSP_PREREQUISITE_DRIVERS shall be registered in the Device Driver Table.[END]
The application conﬁguration option shall disable the use of BSP-provided default values forapplication conﬁguration options.[END]
The application conﬁguration option shall disable the thread-speciﬁc Newlib reentrancy sup-port.[END]
Where the application was conﬁgured to construct the Real-Time Executive for Multiprocessor Systems initialization task using CON-FIGURE_INIT_TASK_CONSTRUCT_STORAGE_SIZE, while the system is initialized, if the taskconstruction fails, then the system shall terminate with the INTERNAL_ERROR_CORE fatalsource and the INTERNAL_ERROR_Real-Time Executive for Multiprocessor Systems_INIT_TASK_CONSTRUCT_FAILED fatal code.[END]
Where the application was conﬁgured with a value not equal to zero for CONFIG-URE_MAXIMUM_THREAD_LOCAL_STORAGE_SIZE, while the system is initialized, if the ac-tual thread-local storage size of the application is greater than the conﬁgure maximum size,then the system shall terminate with the INTERNAL_ERROR_CORE fatal source and the IN-TERNAL_ERROR_TOO_LARGE_TLS_SIZE fatal code.[END]
The application conﬁguration option shall deﬁne the IDLE task body .[END]
The application conﬁguration option shall indicate that the user has conﬁgured nouser ini-tialization tasks or threads and that the user-provided IDLE task will perform applicationinitialization and then transform itself into an IDLE task.[END]
The application conﬁguration option shall deﬁne the task stack size for an IDLE task.[END]
While CONFIGURE_INIT is deﬁned, while rtems/confdefs.h is included in a translation unitafter the deﬁnition of CONFIGURE_INIT, when the translation unit is preprocessed and com-piled, the system settings deﬁned by present application conﬁguration options shall be stati-cally allocated and initialized.[END]
The application conﬁguration option shall deﬁne the task argument of the Classic Application Programming Interface initial-ization task.[END]
The application conﬁguration option shall deﬁne the task attributes of the Classic Application Programming Interface initial-ization task.[END]
The application conﬁguration option shall deﬁne the task storage size of the Classic Application Programming Interface ini-tialization task.[END]
The application conﬁguration option shall deﬁne the entry point of the Classic Application Programming Interface initializa-tion task.[END]
The application conﬁguration option shall deﬁne the initial execution mode of the Classic Application Programming Interfaceinitialization task.[END]
The application conﬁguration option shall deﬁne the name of the Classic Application Programming Interface initializationtask.[END]
The application conﬁguration option shall deﬁne the initial priority of the Classic Application Programming Interface initial-ization task.[END]
The application conﬁguration option shall add the value to the initial extension sets.[END]
The application conﬁguration option shall deﬁne the size of an interrupt stack in bytes.[END]
Where CONFIGURE_DISABLE_BSP_SETTINGS is not deﬁned by the application, where CON-FIGURE_MALLOC_BSP_SUPPORTS_SBRK is deﬁned by the BSP, when the application conﬁg-uration is initialized, not all memory shall made available to the C Program Heap immediatelyat system initialization time.[END]
The application conﬁguration option shall deﬁne the maximum number of Classic Application Programming Interface Barriersthat can be concurrently active.[END]
The application conﬁguration option shall deﬁne the maximum number of ﬁle like objectsthat can be concurrently open.[END]
The application conﬁguration option shall deﬁne the maximum number of Classic Application Programming Interface Mes-sage Queues that can be concurrently active.[END]
The application conﬁguration option shall deﬁne the maximum number of Classic Application Programming Interface Parti-tions that can be concurrently active.[END]
The application conﬁguration option shall deﬁne the maximum number of Classic Application Programming Interface Periodsthat can be concurrently active.[END]
The application conﬁguration option shall deﬁne the maximum numeric priority of tasks.[END]
The application conﬁguration option shall deﬁne the maximum number of processors anapplication intends to use.[END]
The application conﬁguration option shall deﬁne the maximum number of Classic Application Programming InterfaceSemaphore that can be concurrently active.[END]
The application conﬁguration option shall deﬁne the maximum number of Classic Application Programming Interface Tasksthat can be concurrently active.[END]
The application conﬁguration option shall deﬁne the maximum thread-local storage size inbytes.[END]
The application conﬁguration option shall deﬁne the maximum number of Classic Application Programming Interface Timersthat can be concurrently active.[END]
The application conﬁguration option shall deﬁne the maximum number of Classic Application Programming Interface UserExtensions that can be concurrently active.[END]
The application conﬁguration option shall deﬁne the length of time in microseconds betweenclock ticks (clock tick quantum).[END]
The application conﬁguration option shall deﬁne the minimum stack size in bytes for everyuser task or thread in the system.[END]
The application conﬁguration option shall deﬁne the minimum count of Classic Application Programming Interface Taskswhich are constructed by rtems_task_construct.[END]
The application conﬁguration option shall enable that exactly one Classic Application Programming Interface initializationtask is conﬁgured.[END]
While the Real-Time Executive for Multiprocessor Systems_SCHEDULER_ASSIGN() macro is used to deﬁne an entry of a CONFIG-URE_SCHEDULER_ASSIGNMENTS application conﬁguration option value, the attributes de-ﬁned by the second parameter shall deﬁne the scheduler assignment attributes for the pro-cessor associated with the entry .[END]
While the Real-Time Executive for Multiprocessor Systems_SCHEDULER_ASSIGN_NO_SCHEDULER deﬁne is used to deﬁne an entryof a CONFIGURE_SCHEDULER_ASSIGNMENTS application conﬁguration option value, theprocessor associated with the entry shall not have a scheduler assigned.[END]
While the Real-Time Executive for Multiprocessor Systems_SCHEDULER_ASSIGN_PROCESSOR_MANDATORY deﬁne is used as thesecond parameter in the Real-Time Executive for Multiprocessor Systems_SCHEDULER_ASSIGN() macro in an entry of a CONFIG-URE_SCHEDULER_ASSIGNMENTS application conﬁguration option value, the presence ofthe processor associated with the entry in the target shall be mandatory .[END]
While the Real-Time Executive for Multiprocessor Systems_SCHEDULER_ASSIGN_PROCESSOR_OPTIONAL deﬁne is used as the sec-ond parameter in the Real-Time Executive for Multiprocessor Systems_SCHEDULER_ASSIGN() macro in an entry of a CONFIG-URE_SCHEDULER_ASSIGNMENTS application conﬁguration option value, the presence ofthe processor associated with the entry in the target shall be optional.[END]
While the Real-Time Executive for Multiprocessor Systems_SCHEDULER_ASSIGN() macro is used to deﬁne an entry of a CONFIG-URE_SCHEDULER_ASSIGNMENTS application conﬁguration option value, the scheduler as-sociated with the ﬁrst parameter shall be assigned to the processor associated with the entry .[END]
The application conﬁguration option shall deﬁne the initial scheduler to processor assign-ments.[END]
The application conﬁguration option shall make the Earliest Deadline First Symmetric Multiprocessing Scheduleralgorithm available to the application.[END]
The application conﬁguration option shall deﬁne the name of the default scheduler.[END]
The application conﬁguration option shall make the Deterministic Priority Scheduler algo-rithm available to the application.[END]
The application conﬁguration option shall deﬁne the entries of the table of conﬁgured sched-ulers.[END]
The application conﬁguration option shall deﬁne the stack allocator allocate handler.[END]
The application conﬁguration option shall deﬁne the stack allocator allocate handler for anIDLE task.[END]
The application conﬁguration option shall deﬁne the stack allocator deallocate handler.[END]
The application conﬁguration option shall indicate that the task stack allocator does not usethe Real-Time Executive for Multiprocessor Systems Workspace.[END]
The application conﬁguration option shall deﬁne the length of the timeslice quantum for eachtask in clock ticks.[END]
When the bsp_interrupt_spurious() (  ) directive is called.[END]
The TN0018_FIX macro shall provide an instruction sequence for Workaround #1 to be placedimmediatly before a jumpl followed by rett pair.[END]
The TN0018_WAIT_IFLUSH macro shall ﬂush the instruction cache.[END]
The TN0018_WRITE_PSR macro shall write the source register to register %psr .[END]
While the system is initialized, if the data cache snooping is disabled on the boot processor,then the system shall terminate with the Real-Time Executive for Multiprocessor Systems_FATAL_SOURCE_BSP fatal source and theLEON3_FATAL_INVALID_CACHE_CONFIG_BOOT_PROCESSOR fatal code. [END]
While the system is initialized, if the data cache snooping is disabled on a secondary processor,then the system shall terminate with the Real-Time Executive for Multiprocessor Systems_FATAL_SOURCE_BSP fatal source and theLEON3_FATAL_INVALID_CACHE_CONFIG_SECONDARY_PROCESSOR fatal code.[END]
If the installation of the clock interrupt entry fails, then the system shall terminate with theReal-Time Executive for Multiprocessor Systems_FATAL_SOURCE_BSP fatal source and the LEON3_FATAL_CLOCK_INITIALIZATIONfatal code.[END]
While the fatal source is not Real-Time Executive for Multiprocessor Systems_FATAL_SOURCE_Symmetric Multiprocessing or the fatal code is notSymmetric Multiprocessing_SHUTDOWN_RESPONSE, the bsp_fatal_extension() directive shall request all otherconﬁgured and present processors to power down. [END]
While the fatal source is Real-Time Executive for Multiprocessor Systems_FATAL_SOURCE_Symmetric Multiprocessing, while the fatal code isSymmetric Multiprocessing_SHUTDOWN_RESPONSE, the bsp_fatal_extension() directive shall power down theprocessor.[END]
While the fatal source is not Real-Time Executive for Multiprocessor Systems_FATAL_SOURCE_Symmetric Multiprocessing or the fatal code is notSymmetric Multiprocessing_SHUTDOWN_RESPONSE, while all shutdown requests responded or a timeout oc-curred, the bsp_fatal_extension() directive shall halt the processor.[END]
While the fatal source is not Real-Time Executive for Multiprocessor Systems_FATAL_SOURCE_Symmetric Multiprocessing or the fatal code isnot Symmetric Multiprocessing_SHUTDOWN_RESPONSE, while all shutdown requests were issued, thebsp_fatal_extension() directive shall wait for at most approximately one millisecond for thepower down response of all other conﬁgured and present processors.[END]
The BSP shall deﬁne BSP_IDLE_TASK_BODY to bsp_idle_thread().[END]
The bsp_idle_thread() function shall perform an endless loop which sets the processor intothe power-down mode using a write to %asr19 in each iteration.[END]
The bsp_idle_thread() function shall be implemented according to Workaround 2 of {errata-gr712rc-08}.[END]
The grlib_load_8 directive shall load an unsigned 8-bit value from the address speciﬁed byaddress and return it.[END]
The grlib_load_16 directive shall load an unsigned 16-bit value from the address speciﬁed byaddress and return it.[END]
The grlib_load_32 directive shall load an unsigned 32-bit value from the address speciﬁed byaddress and return it.[END]
The grlib_load_64 directive shall load an unsigned 64-bit value from the address speciﬁed byaddress and return it.[END]
The grlib_store_8 directive shall store the unsigned 8-bit value speciﬁed by value to the ad-dress speciﬁed by address.[END]
The grlib_store_16 directive shall store the unsigned 16-bit value speciﬁed by value to theaddress speciﬁed by address.[END]
The grlib_store_32 directive shall store the unsigned 32-bit value speciﬁed by value to theaddress speciﬁed by address.[END]
The grlib_store_64 directive shall store the unsigned 64-bit value speciﬁed by value to theaddress speciﬁed by address.[END]
When the clock_nanosleep() (  ) directive is called.[END]
When the ﬂsl() ( /ﬂsl ) directive is called.[END]
The memcpy() function shall be speciﬁed by C11.[END]
The memset() function shall be speciﬁed by C11.[END]
When the posix_memalign() (  ) directive is called.[END]
When the apbuart_inbyte_nonblocking() ( nonblocking ) directive is called.[END]
The apbuart_outbyte_polled directive shall wait until the transmitter FIFO is empty and thenwrite the characters speciﬁed by ch as an unsigned 8-bit value to the data register of theregister block speciﬁed by regs.[END]
The apbuart_outbyte_wait directive shall wait until the transmitter FIFO is empty indicatedby the status register of the register block speciﬁed by regs.[END]
When the irqamp_get_timestamp_registers() ( timestamp ) directive is called.[END]
When the _Fast User-Space Locking_Wait() (  ) directive is called.[END]
When the _Fast User-Space Locking_Wake() (  ) directive is called.[END]
The _Mutex_Acquire() directive shall seize the mutex as speciﬁed by /score/mtx/req/seize-wait.[END]
The _Mutex_Acquire_timed() directive shall seize the mutex as speciﬁed by/score/mtx/req/seize-wait.[END]
While the timeout parameter speciﬁes a valid absolute CLOCK_REALTIME time point, whilethe mutex is not avaiable at the speciﬁed time point, the directive shall return with a statuscode of ETIMEDOUT.[END]
While the mutex is not available, while the timeout parameter does not specify a valid ab-solute CLOCK_REALTIME time point, if an attempt to acquire the mutex is made, then thedirective shall immediately return with a status code of EINVAL.[END]
The mutex operations shall use the O(m) Independence-Preserving Protocol locking protocol.[END]
The _Mutex_recursive_Acquire() directive shall seize the mutex as speciﬁed by/score/mtx/req/seize-wait.[END]
The _Mutex_recursive_Acquire_timed() directive shall seize the mutex as speciﬁed by/score/mtx/req/seize-wait.[END]
The mutex may be acquired recursively .[END]
When an attempt to recursively acquire the mutex is made, the directive shall immediatelyreturn with a status code of EBUSY.[END]
When an attempt to recursively acquire the mutex is made, the system shallterminate with the INTERNAL_ERROR_CORE fatal source and the INTER-NAL_ERROR_THREAD_QUEUE_DEADLOCK fatal code.[END]
The _Mutex_Release() directive shall surrender the mutex as speciﬁed by/score/mtx/req/surrender.[END]
The _Mutex_recursive_Try_acquire() directive shall seize the mutex as speciﬁed by/score/mtx/req/seize-try .[END]
The _Mutex_Release() directive shall surrender the mutex as speciﬁed by/score/mtx/req/surrender.[END]
The _Mutex_Try_acquire() directive shall seize the mutex as speciﬁed by/score/mtx/req/seize-try .[END]
If the system detects a fatal error, then it shall terminate the system.[END]
When the rtems_barrier_create() (  ) directive is called.[END]
When the rtems_barrier_delete() (  ) directive is called.[END]
The rtems_barrier_ident directive shall identify an Classic Application Programming Interface barrier class object by its nameas speciﬁed by /rtems/req/ident-local.[END]
When the rtems_barrier_release() (  ) directive is called.[END]
When the rtems_barrier_wait() (  ) directive is called.[END]
The Real-Time Executive for Multiprocessor Systems_SYMBOL_NAME macro shall expand to the ELF symbol name associated withthe C language identiﬁer speciﬁed by the _name parameter.[END]
The _name parameter value shall be expanded by the C preprocessor.[END]
Where the target has a data cache, where the data cache can be disabled, when thertems_cache_disable_data directive is called, the data cache shall be disabled.[END]
Where the target has an instruction cache, where the instruction cache can be disabled, whenthe rtems_cache_disable_instruction directive is called, the instruction cache shall be dis-abled.[END]
Where the target has a data cache, where the data cache can be enabled, when thertems_cache_enable_data directive is called, the data cache shall be enabled.[END]
Where the target has an instruction cache, where the instruction cache can be enabled, whenthe rtems_cache_enable_instruction directive is called, the instruction cache shall be enabled.[END]
Where the target has a data cache, where the data cache can be ﬂushed, when thertems_cache_ﬂush_entire_data directive is called, the data cache shall be ﬂushed.[END]
Where the target has a data cache, where data cache lines can be ﬂushed, where the datacache is not coherent with all bus masters, when the rtems_cache_ﬂush_multiple_data_linesdirective is called, the data cache lines covering the memory area speciﬁed by begin and sizeshall be ﬂushed.[END]
Where the target has a data cache, where the data cache can be frozen, when thertems_cache_freeze_data directive is called, the data cache shall be frozen.[END]
Where the target has an instruction cache, where the instruction cache can be frozen, whenthe rtems_cache_freeze_instruction directive is called, the instruction cache shall be frozen.[END]
Where the target has a data cache, the rtems_cache_get_data_line_size directive shall returnthe size of the data cache line.[END]
Where the target has a data cache, while the level parameter is greater than zero, while thelevel parameter is associated with a data cache level, the rtems_cache_get_data_cache_sizedirective shall return the size of the data cache of the level speciﬁed by level.[END]
Where the target has a data cache, while the level parameter is equal to zero, thertems_cache_get_data_cache_size directive shall return the size of the entire data cache.[END]
Where the target has a data cache, while the level parameter is greater thanzero, while the level parameter is not associated with a data cache level, thertems_cache_get_data_cache_size directive shall return zero.[END]
Where the target has an instruction cache, the rtems_cache_get_instruction_line_size direc-tive shall return the size of the instruction cache line.[END]
Where the target has an instruction cache, while the level parameter is greater thanzero, while the level parameter is associated with an instruction cache level, thertems_cache_get_instruction_cache_size directive shall return the size of the instructioncache of the level speciﬁed by level.[END]
Where the target has an instruction cache, while the level parameter is equal to zero, thertems_cache_get_instruction_cache_size directive shall return the size of the entire instruc-tion cache.[END]
Where the target has an instruction cache, while the level parameter is greater thanzero, while the level parameter is not associated with an instruction cache level, thertems_cache_get_instruction_cache_size directive shall return zero.[END]
Where the target has a data cache or an instruction cache, thertems_cache_get_maximal_line_size directive shall return the maximal cache line sizeof all caches.[END]
Where the target has an instruction cache, where the instruction cache needs to be synchro-nized after code changes, when the rtems_cache_instruction_sync_after_code_change direc-tive is called, the instruction cache shall be synchronized so that the code in the memory areaspeciﬁed by begin and size will be fetched when it needs to be executed.[END]
Where the target has a data cache, where the data cache can be ﬂushed and invalidated, whenthe rtems_cache_invalidate_entire_data directive is called, the data cache shall be ﬂushed andinvalidated.[END]
Where the target has an instruction cache, where the instruction cache can be invalidated,when the rtems_cache_invalidate_entire_instruction directive is called, the instruction cacheshall be invalidated.[END]
Where the target has a data cache, where data cache lines can be invali-dated, where the data cache is not coherent with all bus masters, when thertems_cache_invalidate_multiple_data_lines directive is called, the data cache lines coveringthe memory area speciﬁed by begin and size shall be invalidated.[END]
Where the target has an instruction cache, where instruction cache lines can be in-validated, where the instruction cache is not coherent with all bus masters, when thertems_cache_invalidate_multiple_instruction_lines directive is called, the instruction cachelines covering the memory area speciﬁed by begin and size shall be invalidated.[END]
Where the target has a data cache, where the data cache can be frozen, when thertems_cache_unfreeze_data directive is called, the data cache shall be not frozen.[END]
Where the target has an instruction cache, where the instruction cache can be frozen, whenthe rtems_cache_unfreeze_instruction directive is called, the instruction cache shall be notfrozen.[END]
The directive shall return a time point during system initialization which is used byCLOCK_REALTIME.[END]
The directive shall return the time elapsed since some ﬁxed time point in the past measuredusing the CLOCK_MONOTONIC at some time point during the directive call.[END]
The directive shall return the time elapsed since some ﬁxed time point in the past measuredusing the CLOCK_MONOTONIC at some time point close to the directive call.[END]
The directive shall return the time elapsed since the Unix epoch measured using theCLOCK_REALTIME at some time point during the directive call.[END]
The directive shall return the time elapsed since the Unix epoch measured using theCLOCK_REALTIME at some time point close to the directive call.[END]
When the rtems_clock_get_tod() (  ) directive is called.[END]
When the rtems_clock_get_uptime() (  ) directive iscalled.[END]
When the rtems_clock_set() (  ) directive is called.[END]
The rtems_conﬁguration_get_idle_task directive shall return the address of task body exe-cuted by each IDLE task.[END]
The rtems_conﬁguration_get_idle_task_stack_size directive shall return the task stack size ofeach IDLE task.[END]
The rtems_conﬁguration_get_interrupt_stack_size directive shall return the interrupt stacksize.[END]
The rtems_conﬁguration_get_maximum_barriers directive shall return the maximum numberof objects managed by the @ref Real-Time Executive for Multiprocessor SystemsApplication Programming InterfaceClassicBarrier that can be concurrently active.[END]
The rtems_conﬁguration_get_maximum_extensions directive shall return the maximum num-ber of objects managed by the @ref Real-Time Executive for Multiprocessor SystemsApplication Programming InterfaceClassicUserExt that can be concurrently active.[END]
The rtems_conﬁguration_get_maximum_message_queues directive shall return the maxi-mum number of objects managed by the @ref Real-Time Executive for Multiprocessor SystemsApplication Programming InterfaceClassicMessage that can be con-currently active.[END]
The rtems_conﬁguration_get_maximum_partitions directive shall return the maximum num-ber of objects managed by the @ref Real-Time Executive for Multiprocessor SystemsApplication Programming InterfaceClassicPart that can be concurrently active.[END]
The rtems_conﬁguration_get_maximum_periods directive shall return the maximum numberof objects managed by the @ref Real-Time Executive for Multiprocessor SystemsApplication Programming InterfaceClassicRatemon that can be concurrently active.[END]
The rtems_conﬁguration_get_maximum_ports directive shall return the maximum number ofobjects managed by the @ref Real-Time Executive for Multiprocessor SystemsApplication Programming InterfaceClassicDPMem that can be concurrently active.[END]
The rtems_conﬁguration_get_maximum_processors directive shall return the maximum num-ber of processors which can be managed by the system.[END]
The rtems_conﬁguration_get_maximum_regions directive shall return the maximum numberof objects managed by the @ref Real-Time Executive for Multiprocessor SystemsApplication Programming InterfaceClassicRegion that can be concurrently active.[END]
The rtems_conﬁguration_get_maximum_semaphores directive shall return the maximumnumber of objects managed by the @ref Real-Time Executive for Multiprocessor SystemsApplication Programming InterfaceClassicSem that can be concurrently ac-tive.[END]
The rtems_conﬁguration_get_maximum_tasks directive shall return the maximum number ofobjects managed by the @ref Real-Time Executive for Multiprocessor SystemsApplication Programming InterfaceClassicTasks that can be concurrently active.[END]
The rtems_conﬁguration_get_maximum_timers directive shall return the maximum numberof objects managed by the @ref Real-Time Executive for Multiprocessor SystemsApplication Programming InterfaceClassicTimer that can be concurrently active.[END]
The rtems_conﬁguration_get_microseconds_per_tick directive shall return the clock tick in-terval in microseconds.[END]
The rtems_conﬁguration_get_milliseconds_per_tick directive shall return the clock tick inter-val in milliseconds.[END]
The rtems_conﬁguration_get_nanoseconds_per_tick directive shall return the clock tick inter-val in nanoseconds.[END]
The rtems_conﬁguration_get_stack_allocate_for_idle_hook directive shall return the stack al-locator allocate handler used to allocate the task stack of each IDLE task.[END]
The rtems_conﬁguration_get_stack_allocate_hook directive shall return the address of thetask stack allocator which is used to allocate the stack for a task which is not an IDLE task.[END]
The rtems_conﬁguration_get_stack_allocator_avoids_work_space di-rective shall return the option value conﬁgured by CONFIG-URE_TASK_STACK_ALLOCATOR_AVOIDS_WORK_SPACE.[END]
The rtems_conﬁguration_get_stack_free_hook directive shall return the address of the taskstack deallocator which is used to free the stack of a task which was allocated by the taskstack allocator.[END]
The rtems_conﬁguration_get_ticks_per_timeslice directive shall return the number of clockticks per timeslice.[END]
When rtems_cpu_usage_reset is called, the CPU usage shall be set to zero for each thread.[END]
The Real-Time Executive for Multiprocessor Systems_ALL_EVENTS constant shall be a constant expression which evaluates toa value of the bitwise or of Real-Time Executive for Multiprocessor Systems_EVENT_0, Real-Time Executive for Multiprocessor Systems_EVENT_1, Real-Time Executive for Multiprocessor Systems_EVENT_2,Real-Time Executive for Multiprocessor Systems_EVENT_3, Real-Time Executive for Multiprocessor Systems_EVENT_4, Real-Time Executive for Multiprocessor Systems_EVENT_5, Real-Time Executive for Multiprocessor Systems_EVENT_6,Real-Time Executive for Multiprocessor Systems_EVENT_7, Real-Time Executive for Multiprocessor Systems_EVENT_8, Real-Time Executive for Multiprocessor Systems_EVENT_9, Real-Time Executive for Multiprocessor Systems_EVENT_10,Real-Time Executive for Multiprocessor Systems_EVENT_11, Real-Time Executive for Multiprocessor Systems_EVENT_12, Real-Time Executive for Multiprocessor Systems_EVENT_13, Real-Time Executive for Multiprocessor Systems_EVENT_14,Real-Time Executive for Multiprocessor Systems_EVENT_15, Real-Time Executive for Multiprocessor Systems_EVENT_16, Real-Time Executive for Multiprocessor Systems_EVENT_17, Real-Time Executive for Multiprocessor Systems_EVENT_18,Real-Time Executive for Multiprocessor Systems_EVENT_19, Real-Time Executive for Multiprocessor Systems_EVENT_20, Real-Time Executive for Multiprocessor Systems_EVENT_21, Real-Time Executive for Multiprocessor Systems_EVENT_22,Real-Time Executive for Multiprocessor Systems_EVENT_23, Real-Time Executive for Multiprocessor Systems_EVENT_24, Real-Time Executive for Multiprocessor Systems_EVENT_25, Real-Time Executive for Multiprocessor Systems_EVENT_26,Real-Time Executive for Multiprocessor Systems_EVENT_27, Real-Time Executive for Multiprocessor Systems_EVENT_28, Real-Time Executive for Multiprocessor Systems_EVENT_29, Real-Time Executive for Multiprocessor Systems_EVENT_30, andReal-Time Executive for Multiprocessor Systems_EVENT_31.[END]
LetJ∈{0,1, ...,31}. The J-th event number constant shall be a constant expression whichevaluates to the integer representation of event number J.[END]
LetJ∈{0,1, ...,31}. The event number Jshall be represented by the integer 2J.[END]
The Real-Time Executive for Multiprocessor Systems_PENDING_EVENTS constant shall be a constant expression which evaluates to avalue of zero.[END]
The rtems_event_receive directive shall receive events from the application event set of a taskas speciﬁed by /rtems/event/req/send-receive.[END]
The rtems_event_send directive shall send events to the application event set of a task asspeciﬁed by /rtems/event/req/send-receive.[END]
When the event send and receive directive variants are called in the speciﬁed system condi-tion.[END]
The rtems_event_system_receive directive shall receive events from the system event set of atask as speciﬁed by /rtems/event/req/send-receive.[END]
The rtems_event_system_send directive shall send events to the system event set of a task asspeciﬁed by /rtems/event/req/send-receive.[END]
When rtems_fatal is called, the system shall terminate with a fatal source speciﬁed by thefatal_source parameter and a fatal code speciﬁed by the fatal_code parameter.[END]
When the rtems_interrupt_clear() (  ) directive is called.[END]
When the directive is called, maskable interrupts shall be disabled on a processor whichexecuted at least one instruction of the directive.[END]
When the rtems_interrupt_entry_initialize directive is called, the arg member of the objectreferenced by the entry parameter shall be set to the value of the arg.[END]
When the rtems_interrupt_entry_initialize directive is called, the handler member of the ob-ject referenced by the entry parameter shall be set to the value of the routine.[END]
When the rtems_interrupt_entry_initialize directive is called, the info member of the objectreferenced by the entry parameter shall be set to the value of the arg.[END]
When the rtems_interrupt_entry_initialize directive is called, the next member of the objectreferenced by the entry parameter shall be set to the value equal to NULL.[END]
When the Real-Time Executive for Multiprocessor Systems_INTERRUPT_ENTRY_INITIALIZER is used to statically initialize an objectof type rtems_interrupt_entry , the arg member of the object shall be initialized to the valueof the _arg .[END]
When the Real-Time Executive for Multiprocessor Systems_INTERRUPT_ENTRY_INITIALIZER is used to statically initialize an objectof type rtems_interrupt_entry , the handler member of the object shall be initialized to thevalue of the _routine .[END]
When the Real-Time Executive for Multiprocessor Systems_INTERRUPT_ENTRY_INITIALIZER is used to statically initialize an objectof type rtems_interrupt_entry , the info member of the object shall be initialized to the valueof the _info .[END]
When the Real-Time Executive for Multiprocessor Systems_INTERRUPT_ENTRY_INITIALIZER is used to statically initialize an objectof type rtems_interrupt_entry , the next member of the object shall be initialized to a valueequal to NULL.[END]
When the rtems_interrupt_entry_install() (  ) directive iscalled.[END]
When the rtems_interrupt_entry_remove() (  ) directiveis called.[END]
When the rtems_interrupt_get_afﬁnity() ( ﬁnity ) directive iscalled.[END]
When the rtems_interrupt_get_attributes() (  ) directiveis called.[END]
When the rtems_interrupt_handler_iterate() (  ) direc-tive is called.[END]
When the rtems_interrupt_is_pending() (  ) directive iscalled.[END]
When the rtems_interrupt_local_disable directive is called, the status of the maskable inter-rupts before maskable interrupts are disabled by the directive shall be assigned to the variablespeciﬁed by the _isr_cookie parameter.[END]
When the rtems_interrupt_local_enable directive is called, the status of maskable interruptsshall be restored according to the _isr_cookie parameter.[END]
When the directive is called, the lock contained in the object referenced by the _lock param-eter shall be acquired.[END]
When the Real-Time Executive for Multiprocessor Systems_INTERRUPT_LOCK_DECLARE is used, it shall expand to an object decla-ration with an identiﬁer speciﬁed by the _designator parameter.[END]
When the Real-Time Executive for Multiprocessor Systems_INTERRUPT_LOCK_DECLARE is used, it shall expand to an object decla-ration with a speciﬁer speciﬁed by the _specifier parameter.[END]
When the Real-Time Executive for Multiprocessor Systems_INTERRUPT_LOCK_DEFINE is used, it shall expand to an object deﬁnitionwith an identiﬁer speciﬁed by the _designator parameter.[END]
When the Real-Time Executive for Multiprocessor Systems_INTERRUPT_LOCK_DEFINE is used, it shall expand to an object deﬁnitionwith a speciﬁer speciﬁed by the _specifier parameter.[END]
When the rtems_interrupt_lock_destroy directive is called, the lock contained in the objectreferenced by the _lock parameter shall be destroyed.[END]
When the rtems_interrupt_lock_initialize directive is called, the lock contained in the objectreferenced by the _lock parameter shall be initialized so that it is available.[END]
When the Real-Time Executive for Multiprocessor Systems_INTERRUPT_LOCK_INITIALIZER is used to statically initialize an objectof type rtems_interrupt_lock, the lock contained in the object shall be initialized so that it isavailable.[END]
When the Real-Time Executive for Multiprocessor Systems_INTERRUPT_LOCK_MEMBER is used, it shall expand to structure or unionmember declaration with an identiﬁer speciﬁed by the _specifier parameter.[END]
When the Real-Time Executive for Multiprocessor Systems_INTERRUPT_LOCK_MEMBER is used, it shall expand to structure or unionmember declaration with a type of rtems_interrupt_lock.[END]
When the Real-Time Executive for Multiprocessor Systems_INTERRUPT_LOCK_REFERENCE is used, it shall expand to an object ref-erence deﬁnition with an identiﬁer speciﬁed by the _designator parameter.[END]
When the Real-Time Executive for Multiprocessor Systems_INTERRUPT_LOCK_REFERENCE is used, it shall expand to an object refer-ence deﬁnition which is initialized to the object reference speciﬁed by the _target parameter.[END]
When the Real-Time Executive for Multiprocessor Systems_INTERRUPT_LOCK_REFERENCE is used, it shall expand to an object ref-erence deﬁnition with a type of a pointer to rtems_interrupt_lock.[END]
When the directive is called, the lock contained in the object referenced by the _lock param-eter shall be released.[END]
When the rtems_interrupt_lock_release directive is called, the status of maskable interruptsshall be restored according to the _lock_context parameter.[END]
When the directive is called, the status of the maskable interrupts before maskable interruptsare disabled by the directive shall be stored to the lock context parameter.[END]
When the rtems_interrupt_raise() (  ) directive is called.[END]
When the rtems_interrupt_raise_on() (  ) directive is called.[END]
When the rtems_interrupt_set_afﬁnity() ( ﬁnity ) directive iscalled.[END]
When the rtems_interrupt_vector_disable() (  ) direc-tive is called.[END]
When the rtems_interrupt_vector_enable() (  ) directiveis called.[END]
When the rtems_interrupt_vector_is_enabled() (  )directive is called.[END]
When the function referenced by BSP_output_char is called, it shall output the characterspeciﬁed by the parameter to the kernel character output device.[END]
While the BSP_poll_char pointer references a function, while the kernel character input de-vice used by the function has a character enqueued, the function shall dequeue the leastrecently enqueued character and return it as an unsigned character value.[END]
While the BSP_poll_char pointer references a function, while the kernel character input de-vice used by the function has no character enqueued, the function shall return minus one.[END]
When the getchark() (  ) directive is called.[END]
When the rtems_put_char() (  ) directive is called.[END]
When the rtems_putc() (  ) directive is called.[END]
When the rtems_calloc() (  ) directive is called.[END]
When the rtems_malloc() (  ) directive is called.[END]
When the rtems_message_queue_broadcast() (  ) di-rective is called.[END]
When the rtems_message_queue_construct() (  ) direc-tive is called.[END]
When the rtems_message_queue_delete() (  ) directive iscalled.[END]
When the rtems_message_queue_ﬂush() ( /ﬂush ) directive iscalled.[END]
The rtems_message_queue_ident directive shall identify an Classic Application Programming Interface message queue classobject by its name as speciﬁed by /rtems/req/ident.[END]
When the rtems_message_queue_receive() (  ) directiveis called.[END]
When the rtems_message_queue_send() (  ) directive iscalled.[END]
When the /rtems/mode/if/interrupt-level macro is used, it shall expand to a constant ex-pression which computes the bitwise and of the value speciﬁed by the _interrupt_levelparameter and Real-Time Executive for Multiprocessor Systems_INTERRUPT_MASK.[END]
When the rtems_build_name directive is called, the directive shall return the return value ofa call to rtems_build_name.[END]
The result of rtems_build_name shall be equal to ( _c1 modulo 256) * 16777216 + ( _c2modulo 256) * 65536 + ( _c3modulo 256) * 256 + ( _c4modulo 256).[END]
The result of rtems_object_get_local_node shall be equal to the local node number.[END]
The Real-Time Executive for Multiprocessor Systems_PARTITION_ALIGNMENT constant shall expand to a constant expression whichevaluates to the value of CPU_SIZEOF_POINTER.[END]
The count of buffers available for use from a partition shall be exactly the buffer area lengthdivided by the buffer size (integer division) speciﬁed at partition creation.[END]
When the rtems_partition_create() (  ) directive is called.[END]
When the rtems_partition_delete() (  ) directive is called.[END]
A partition shall maintain free buffers in FIFO order.[END]
When the rtems_partition_get_buffer() (  ) directive iscalled.[END]
The rtems_partition_ident directive shall identify an Classic Application Programming Interface partition class object by itsname as speciﬁed by /rtems/req/ident.[END]
When the rtems_partition_return_buffer() (  ) directiveis called.[END]
When the rtems_rate_monotonic_cancel() (  ) directive iscalled.[END]
When the rtems_rate_monotonic_create() (  ) directive iscalled.[END]
When the rtems_rate_monotonic_delete() (  ) directive iscalled.[END]
When the rtems_rate_monotonic_get_status() (  ) di-rective is called.[END]
The rtems_rate_monotonic_ident directive shall identify an Classic Application Programming Interface rate monotonic classobject by its name as speciﬁed by /rtems/req/ident-local.[END]
When the rtems_rate_monotonic_period() (  ) directive iscalled.[END]
When the rate monotonic period timer expires.[END]
When the speciﬁed object identiﬁcation directive is called.[END]
When the speciﬁed object identiﬁcation directive is called.[END]
When the rtems_scheduler_add_processor() (  )directive is called.[END]
When the rtems_scheduler_get_maximum_priority() ( maximum-priority ) directive is called.[END]
When the rtems_scheduler_get_processor directive is called, the directive shall return thereturn value of a call to rtems_scheduler_get_processor.[END]
When the rtems_scheduler_get_processor_maximum directive is called, the directive shallreturn the return value of a call to rtems_scheduler_get_processor_maximum.[END]
The return value of the rtems_scheduler_get_processor_maximum directive shallbe the minimum of the processors available at the target and the CONFIG-URE_MAXIMUM_PROCESSORS application conﬁguration option value.[END]
When the rtems_scheduler_get_processor_set() ( processor-set ) directive is called.[END]
The return value of the rtems_scheduler_get_processor directive shall be the index of a pro-cessor which executed at least one instruction of the directive call.[END]
When the rtems_scheduler_ident() (  ) directive is called.[END]
When the rtems_scheduler_ident_by_processor() ( processor ) directive is called.[END]
When the rtems_scheduler_ident_by_processor_set() ( by-processor-set ) directive is called.[END]
When the rtems_scheduler_remove_processor() ( processor ) directive is called.[END]
When the rtems_semaphore_create() (  ) directive is called.[END]
When the rtems_semaphore_delete() (  ) directive is called.[END]
When the rtems_semaphore_ﬂush() ( /ﬂush ) directive is called.[END]
The rtems_semaphore_ident directive shall identify an Classic Application Programming Interface semaphore class object byits name as speciﬁed by /rtems/req/ident.[END]
When a Multiprocessor Resource-Sharing Protocol semaphore is obtained.[END]
While a thread is waiting to obtain a Multiprocessor Resource-Sharing Protocol semaphore, while its current priority changed sothat it is higher than the ceiling priority of the semaphore, the thread is allowed to becomethe new owner of the semaphore.[END]
Where an uniprocessor scheduler is conﬁgured, the owner of a semaphore created with theReal-Time Executive for Multiprocessor Systems_MULTIPROCESSOR_RESOURCE_SHARING attribute shall not be made sticky .[END]
When the rtems_semaphore_obtain() (  ) directive is called.[END]
When the rtems_semaphore_release() (  ) directive is called.[END]
When the rtems_semaphore_set_priority() (  ) directive iscalled.[END]
When a semaphore obtain timeout happens.[END]
When the rtems_signal_catch() (  ) directive is called.[END]
When the rtems_signal_send() (  ) directive is called.[END]
LetJ∈{0,1, ...,31}. The J-th signal constant shall be a constant expression which evaluatesto the integer representation of signal J.[END]
The @ref Real-Time Executive for Multiprocessor SystemsApplication Programming InterfaceClassicSignal shall support exactly 32 signals.[END]
LetJ∈{0,1, ...,31}. While a task is able to catch signals, when signal Jis sent to the task, itshall be caught by the task as exactly signal J.[END]
LetJ∈{0,1, ...,31}. The signal Jshall be represented by the integer 2J.[END]
LetJ∈{0,1, ...,31}. The rtems_signal_set integer type shall be able to represent the integerrepresentation of signal J.[END]
The Real-Time Executive for Multiprocessor Systems_STATUS_CODES_FIRST constant shall be equal to the minimum value of allrtems_status_code enumerators.[END]
When the rtems_are_statuses_equal() (  ) directive iscalled.[END]
When the rtems_is_status_successful() (  ) directive iscalled.[END]
The Real-Time Executive for Multiprocessor Systems_STATUS_CODES_LAST constant shall be equal to the maximum value of allrtems_status_code enumerators.[END]
When the rtems_status_text() (  ) directive is called.[END]
When the rtems_is_name_valid() (  ) directive iscalled.[END]
When the call to rtems_name_to_characters returned, the object referenced by the c1 param-eter shall be set the value of name divided by 16777216 modulo 256.[END]
When the call to rtems_name_to_characters returned, the object referenced by the c2 param-eter shall be set the value of name divided by 65536 modulo 256.[END]
When the call to rtems_name_to_characters returned, the object referenced by the c3 param-eter shall be set the value of name divided by 256 modulo 256.[END]
When the call to rtems_name_to_characters returned, the object referenced by the c4 param-eter shall be set the value of name modulo 256.[END]
The Real-Time Executive for Multiprocessor Systems_CONFIGURED_MINIMUM_STACK_SIZE constant shall expand to a constant ex-pression which evaluates to the value of zero.[END]
When the rtems_task_construct() (  ) directive is called.[END]
When a task is constructed, the home scheduler of the constructed task shall be set to thehome scheduler of the task calling the rtems_task_construct directive at some time pointduring the directive call.[END]
When the rtems_task_create() (  ) directive is called.[END]
When a task is created, the home scheduler of the created task shall be set to the homescheduler of the task calling the rtems_task_create directive at some time point during thedirective call.[END]
When the rtems_task_delete() (  ) directive is called.[END]
When the rtems_task_exit() (  ) directive is called.[END]
When the rtems_task_get_afﬁnity() ( ﬁnity ) directive is called.[END]
When the rtems_task_get_priority() (  ) directive is called.[END]
When the rtems_task_get_scheduler() (  ) directive iscalled.[END]
When the rtems_task_ident() (  ) directive is called.[END]
When the rtems_task_is_suspended() (  ) directive iscalled.[END]
While an iteration over all tasks was started by calling rtems_task_iterate, while no taskexists which was not visited, the iteration shall stop and then the object allocator lock shallbe released.[END]
When rtems_task_iterate is called, the calling task shall obtain the object allocator lock andthen start an iteration over all tasks.[END]
While an iteration over all tasks was started by calling rtems_task_iterate, when the functionspeciﬁed by the visitor returns true during the iteration, the iteration shall stop and the objectallocator lock shall be released.[END]
While an iteration over all tasks was started by calling rtems_task_iterate, while a task existswhich was not visited, the task shall be visited by calling the function speciﬁed by the visitorparameter of the rtems_task_iterate with the TCB of the task as the ﬁrst parameter and thesecond parameter speciﬁed by the visitor parameter of the rtems_task_iterate call.[END]
The Real-Time Executive for Multiprocessor Systems_MAXIMUM_PRIORITY runtime constant shall be equal to the lowest priority ofthe scheduler with index zero.[END]
The Real-Time Executive for Multiprocessor Systems_MINIMUM_PRIORITY constant shall expand to a constant expression which eval-uates to the highest task priority available to application tasks.[END]
The Real-Time Executive for Multiprocessor Systems_MINIMUM_STACK_SIZE constant shall expand to a constant expression whichevaluates to the value of STACK_MINIMUM_SIZE.[END]
When the rtems_task_mode() (  ) directive is called.[END]
The /rtems/task/if/no-priority constant shall expand to a constant expression which evalu-ates to the value of Real-Time Executive for Multiprocessor Systems_CURRENT_PRIORITY.[END]
When the rtems_task_restart() (  ) directive is called.[END]
When the rtems_task_resume() (  ) directive is called.[END]
The rtems_task_self directive call shall return the object identiﬁer of the calling task.[END]
While the Real-Time Executive for Multiprocessor Systems_SELF constant is used as a task identiﬁer parameter in a directive call, itshall be associated with the calling task.[END]
When the rtems_task_set_afﬁnity() ( ﬁnity ) directive is called.[END]
When the rtems_task_set_priority() (  ) directive is called.[END]
When the rtems_task_set_scheduler() (  ) directive iscalled.[END]
When the rtems_task_start() (  ) directive is called.[END]
The Real-Time Executive for Multiprocessor Systems_TASK_STORAGE_ALIGNMENT constant shall expand to a constant expressionwhich evaluates to the value of CPU_STACK_ALIGNMENT.[END]
When the Real-Time Executive for Multiprocessor Systems_TASK_STORAGE_SIZE() (  ) directiveis called.[END]
When the rtems_task_suspend() (  ) directive is called.[END]
When the rtems_task_wake_after() (  ) directive is called.[END]
When the rtems_task_wake_when() (  ) directive iscalled.[END]
When the rtems_timer_cancel() (  ) directive is called.[END]
When the rtems_timer_create() (  ) directive is called.[END]
When the rtems_timer_delete() (  ) directive is called.[END]
When the rtems_timer_ﬁre_after() ( /ﬁre-after ) directive is called.[END]
The timer scheduled at the same processor with the same expiration time point shall ﬁre inFIFO order.[END]
When the rtems_timer_ﬁre_when() ( /ﬁre-when ) directive is called.[END]
The rtems_timer_ident directive shall identify an Classic Application Programming Interface timer class object by its name asspeciﬁed by /rtems/req/ident-local.[END]
When the rtems_timer_initiate_server() (  ) directiveis called.[END]
When the rtems_timer_reset() (  ) directive is called.[END]
When the rtems_timer_server_ﬁre_after() ( ﬁre-after ) direc-tive is called.[END]
When the rtems_timer_server_ﬁre_when() ( ﬁre-when ) di-rective is called.[END]
The Real-Time Executive for Multiprocessor Systems_ID_NONE constant shall be a constant expression which evaluates to an invalidobject identiﬁer.[END]
When the rtems_extension_create() (  ) directive is called.[END]
When the rtems_extension_delete() (  ) directive is called.[END]
While the user extensions are iterated to invoke the fatal extensions, when an extension setis removed, the removed extension set shall not be a next extension set for any iteration inprogress after the removal.[END]
The fatal user extensions shall be invoked in extension forward order.[END]
The rtems_extension_ident directive shall identify an Classic Application Programming Interface user extension class objectby its name as speciﬁed by /rtems/req/ident-local.[END]
While the user extensions are iterated to invoke the thread begin extensions, when an ex-tension set is removed, the removed extension set shall not be a next extension set for anyiteration in progress after the removal.[END]
The thread begin user extensions shall be invoked in extension forward order.[END]
The thread invoking the thread create user extensions shall be the owner of the allocatormutex.[END]
While the user extensions are iterated to invoke the thread create extensions, when an ex-tension set is removed, the removed extension set shall not be a next extension set for anyiteration in progress after the removal.[END]
The thread create user extensions shall be invoked in extension forward order.[END]
The thread invoking the thread delete user extensions shall be the owner of the allocatormutex.[END]
While the user extensions are iterated to invoke the thread delete extensions, when an ex-tension set is removed, the removed extension set shall not be a next extension set for anyiteration in progress after the removal.[END]
The thread delete user extensions shall be invoked in extension reverse order.[END]
While the user extensions are iterated to invoke the thread exitted extensions, when an ex-tension set is removed, the removed extension set shall not be a next extension set for anyiteration in progress after the removal.[END]
The thread exitted user extensions shall be invoked in extension forward order.[END]
While the user extensions are iterated to invoke the thread restart extensions, when an ex-tension set is removed, the removed extension set shall not be a next extension set for anyiteration in progress after the removal.[END]
The thread restart user extensions shall be invoked in extension forward order.[END]
While the user extensions are iterated to invoke the thread start extensions, when an ex-tension set is removed, the removed extension set shall not be a next extension set for anyiteration in progress after the removal.[END]
The thread start user extensions shall be invoked in extension forward order.[END]
The thread switch user extensions shall be invoked in extension forward order.[END]
While the user extensions are iterated to invoke the thread terminate extensions, when anextension set is removed, the removed extension set shall not be a next extension set for anyiteration in progress after the removal.[END]
The thread terminate user extensions shall be invoked in extension reverse order.[END]
The _CPU_Fatal_halt() function shall halt or reset the target.[END]
The _CPU_Fatal_halt() directive shall cause a system error halt with the primary exit code setto the fatal source and the secondary exit code set to the fatal code.[END]
The _Terminate() function shall terminate the system.[END]
While _Terminate() executes, when the system state was set, a shutdown request to all con-ﬁgured processors shall be issued.[END]
While _Terminate() executes, when the shutdown request was issued, the system shall halt.[END]
While _Terminate() executes, when the fatal extensions were invoked, the system state shallbe set to terminated.[END]
When _Terminate() is called, the fatal user extensions shall be invoked with the fatal sourceand fatal code speciﬁed by the respective parameter.[END]
When the calling thread tries to seize the mutex.[END]
When the calling thread tries to seize the mutex.[END]
When the calling thread surrenders the mutex.[END]
The object services shall use a mutex to protect the object allocation and deallocation.[END]
If obtaining the object allocator mutex would result in a deadlock, then the sys-tem shall terminate with the INTERNAL_ERROR_CORE fatal source and the INTER-NAL_ERROR_THREAD_QUEUE_DEADLOCK fatal code.[END]
When the thread yields.[END]
ﬃnityﬁnityWhen the thread to processor afﬁnity is set for task T.[END]
ﬃnity-unsupported-subsetﬁnity-unsupported-subsetWhile a thread to processor afﬁnity set is a proper subset of the set of the online processors,while the afﬁnity set contains at least two processors, while at least one processor of theafﬁnity set is owned by a scheduler, while a thread uses the scheduler as its home scheduler,when an attempt is made to set the thread to processor afﬁnity set of the thread to the afﬁnityset, the operation shall abort with an error status derived from STATUS_INVALID_NUMBER.[END]
While a thread is registered for help in a helping scheduler, while the thread is scheduled byanother scheduler or blocked, when the helping scheduler tries to schedule the thread, thethread shall be blocked with respect to the helping scheduler. [END]
While a thread is registered for help in its home scheduler, while the thread is scheduled byanother scheduler, while the thread is not sticky , when the home scheduler tries to schedulethe thread, the thread shall be blocked with respect to the home scheduler.[END]
When a need for help is detected for a thread, the ask for help request shall be registered onthe current processor.[END]
While a thread is scheduled by the home scheduler, while an idle thread executes on behalfof the thread in the home scheduler, when the thread is blocked, the idle thread executing onbehalf of the thread shall continue to execute on behalf of the thread.[END]
While an idle thread is scheduled on behalf of a thread by the home scheduler, while thethread is not scheduled by another scheduler, when the thread is rescheduled by the homescheduler, the thread shall be scheduled.[END]
While a thread is scheduled by a helping scheduler, while the thread is blocked, when thethread is preempted by the helping scheduler, the thread shall be blocked by the helpingscheduler.[END]
When the calling task tries to seize the semaphore.[END]
When the calling task tries to seize the semaphore.[END]
When the calling surrenders the semaphore.[END]
While the system is initialized, if the boot processor is not assigned to a scheduler, thenthe system shall terminate with the Real-Time Executive for Multiprocessor Systems_FATAL_SOURCE_Symmetric Multiprocessing fatal source and theSymmetric Multiprocessing_FATAL_BOOT_PROCESSOR_NOT_ASSIGNED_TO_SCHEDULER fatal code.[END]
While the system is initialized, if a mandatory processor deﬁned by the application conﬁgu-ration is not present, then the system shall terminate with the Real-Time Executive for Multiprocessor Systems_FATAL_SOURCE_Symmetric Multiprocessingfatal source and the Symmetric Multiprocessing_FATAL_MANDATORY_PROCESSOR_NOT_PRESENT fatal code.[END]
While the system is initialized, if multitasking is started on a processor those index isgreater than or equal to the processor maximum deﬁned by the application conﬁguration,then the system shall terminate with the Real-Time Executive for Multiprocessor Systems_FATAL_SOURCE_Symmetric Multiprocessing fatal source and theSymmetric Multiprocessing_FATAL_MULTITASKING_START_ON_INVALID_PROCESSOR fatal code.[END]
While the system is initialized, if multitasking is started on a processor whichhas no scheduler assigned by the application conﬁguration, then the systemshall terminate with the Real-Time Executive for Multiprocessor Systems_FATAL_SOURCE_Symmetric Multiprocessing fatal source and theSymmetric Multiprocessing_FATAL_MULTITASKING_START_ON_UNASSIGNED_PROCESSOR fatal code.[END]
Where the conﬁgured scheduler does support exactly one processor, where the sys-tem has not exactly one processor, if the system is initialized, then the sys-tem shall terminate with the Real-Time Executive for Multiprocessor Systems_FATAL_SOURCE_Symmetric Multiprocessing fatal source and theSymmetric Multiprocessing_FATAL_SCHEDULER_REQUIRES_EXACTLY_ONE_PROCESSOR fatal code.[END]
If the processor receives an Symmetric Multiprocessing shutdown request message, then the system shall terminatewith the Real-Time Executive for Multiprocessor Systems_FATAL_SOURCE_Symmetric Multiprocessing fatal source and the Symmetric Multiprocessing_SHUTDOWN_RESPONSEfatal code.[END]
While the system is initialized, if the start of a mandatory processor deﬁned by the applicationconﬁguration fails, then the system shall terminate with the Real-Time Executive for Multiprocessor Systems_FATAL_SOURCE_Symmetric Multiprocessingfatal source and the Symmetric Multiprocessing_FATAL_START_OF_MANDATORY_PROCESSOR_FAILED fatal code.[END]
If multitasking is started on a not online processor, then the systemshall terminate with the Real-Time Executive for Multiprocessor Systems_FATAL_SOURCE_Symmetric Multiprocessing fatal source and theSymmetric Multiprocessing_FATAL_START_ON_NOT_ONLINE_PROCESSOR fatal code.[END]
If the target processor of a job is not in the initial, ready to start multiprocessing, or up state,then the system shall terminate with the Real-Time Executive for Multiprocessor Systems_FATAL_SOURCE_Symmetric Multiprocessing fatal source and theSymmetric Multiprocessing_FATAL_START_OF_MANDATORY_PROCESSOR_FAILED fatal code.[END]
Per-processor jobs shall be processed in FIFO order.[END]
Processors which were successfully started shall be marked as online.[END]
While the system is initialized, if the start of an optional processor deﬁned by the applicationconﬁguration fails, then the system initialization shall continue.[END]
Processors which failed to start shall not be marked as online.[END]
While a terminating thread has exactly one joining thread, while the joining thread can becancelled, if the terminating thread cancels the joining thread, then the terminating threadshall wait for threads to join. [END]
While the thread dispatch disable level is not equal to one, if a direct thread dispatch isdone, then the system shall terminate with the INTERNAL_ERROR_CORE fatal source andthe INTERNAL_ERROR_BAD_THREAD_DISPATCH_DISABLE_LEVEL fatal code.[END]
Where the system needs inter-processor interrupts, if a thread dispatch is done with maskableinterrupts disabled, then the system shall terminate with the INTERNAL_ERROR_CORE fatalsource and the INTERNAL_ERROR_BAD_THREAD_DISPATCH_ENVIRONMENT fatal code.[END]
If a thread body function returned and the thread exitted extension invocation for the threadreturned, then the system shall terminate with the INTERNAL_ERROR_CORE fatal sourceand the INTERNAL_ERROR_THREAD_EXITTED fatal code.[END]
While a thread is pinned, while the thread executes on a processor which is not owned by itshome scheduler, the thread shall only use the scheduler of the processor to which it is pinned.[END]
A thread may be pinned more than once at a time.[END]
While a thread is pinned, the thread may be preempted by a scheduler.[END]
While a thread is suspended, the thread may be unpinned.[END]
While a thread is suspended, the thread shall not reconsider help requests.[END]
Where the system does not need inter-processor interrupts, when a thread dispatch is donewith maskable interrupts disabled, the thread dispatch shall be carried out.[END]
The alignment of thread-local storage objects may be greater than CPU_STACK_ALIGNMENT.[END]
While the thread entry execution begins, the value of non-zero initialized thread-local storageobjects shall be the initialization value.[END]
Where the conﬁgured maximum thread-local storage size is equal to zero, the thread-localstorage allocation size shall be deﬁned by the thread-local storage size of the applicationexecutable.[END]
While the thread entry execution begins, the storage space of zero initialized thread-localstorage objects shall be cleared to zero.[END]
The initial value of the CLOCK_MONOTONIC shall be 0000-00-00T00:00:01.000000000.[END]
While no timecounter is installed, the CLOCK_MONOTONIC shall remain at the initial value.[END]
The initial value of the CLOCK_REALTIME shall be 1988-01-01T00:00:00.000000000.[END]
While no timecounter is installed, the CLOCK_REALTIME shall remain at the initial value.[END]
The directives to get time values in a coarse resolution shall not use the currently installedtimecounter.[END]
The directives to get time values in the highest resolution shall use the currently installedtimecounter to get a clock snapshot.[END]
While the timehand used to get the time was not updated for one second or more, while thetimecounter of the timehand did not overﬂow, the directives to get time values in the highestresolution shall return the correct time.[END]
While the timecounter to install has a quality level equal to the quality level of the currentlyinstalled timecounter, while the timecounter to install has a higher frequancy greater than thefrequency of the currently installed timecounter, the timecounter to install shall be installed.[END]
While the timecounter to install has a quality level greater than the quality level of the cur-rently installed timecounter, the timecounter to install shall be installed.[END]
While the timehand is updated, when the NTP handler is called, the value returned by theadjustment parameter shall be used to adjust the timecounter frequency of the timehand.[END]
While the timehand is updated, when the NTP handler is called, the value returned by thenewsec parameter shall deﬁne the seconds value of the CLOCK_REALTIME time point of thetimehand.[END]
Let Tbe the seconds value of the CLOCK_REALTIME time point of the timehand which iscurrently updated, let Sbe the seconds value of the CLOCK_REALTIME time point of theprevious timehand, let DbeTminus S, while the NTP handler is not NULL, while Dis greaterthan or equal to one, while Dis less than or equal to 200, while the timehand is updated, theNTP handler shall be called exactly Dtimes.[END]
Let Tbe the seconds value of the CLOCK_REALTIME time point of the timehand which iscurrently updated, let Sbe the seconds value of the CLOCK_REALTIME time point of theprevious timehand, let DbeTminus S, while the NTP handler is not NULL, while Dis greaterthan 200, while the timehand is updated, the NTP handler shall be called exactly two times.[END]
While the oldest timehand was not updated for one second or more, while the time intervalfrom the time point of the timehand to the time point of the update is measureable with thetimecounter of the timehand, the time point of the timehand shall be incremented by the timeinterval.[END]
When the simple timecounter tick service is called, the time points of the current timehandshall be advanced by the time interval speciﬁed by the delta parameter.[END]
When the simple timecounter tick service is called, the timecounter offset of the currenttimehand shall be set to the offset speciﬁed by the offset parameter.[END]
While a thread Atries to enqueue on a thread queue X, while a thread Btries to enqueueon a thread queue Y, while the thread queue dependency graph built up by threads Aand Bcontains a cycle, the deadlock shall be detected.[END]
When the calling thread is enqueued on the thread queue.[END]
When the calling thread attempts to be enqueued on the thread queue.[END]
When the calling thread is enqueued on the thread queue.[END]
When the calling thread is enqueued on the thread queue.[END]
When the calling task is enqueued on the thread queue.[END]
When the calling task is enqueued on the thread queue.[END]
While no deadlock was detected in a sticky thread queue enqueue, while the thread dis-patch disable level is not equal to one, if the sticky thread queue enqueue is performed, thenthe system shall terminate with the INTERNAL_ERROR_CORE fatal source and the INTER-NAL_ERROR_THREAD_QUEUE_ENQUEUE_STICKY_FROM_BAD_STATE fatal code.[END]
When the FIFO thread queue is ﬂushed.[END]
The thread queue ﬂush operation shall invoke the caller provided ﬁlter handler for eachthread to extract.[END]
When the caller provided ﬁlter handler returns a value equal to NULL, the thread queue ﬂushoperation shall stop extracting threads from the thread queue.[END]
When the priority thread queue is ﬂushed.[END]
When the priority thread queue with support for priority inheritance is ﬂushed.[END]
While the extracted thread is in the blocked wait state, the thread queue ﬂush operation shallremove the thread timer.[END]
While the extracted thread is in the blocked wait state, the thread queue ﬂush operation shallunblock the thread.[END]
Where the thread queue uses a priority discipline, when the priority of an enqueued threadchanges, the position of the enqueued thread shall be changed to reﬂect its new priority .[END]
When the thread queue enqueue operation timed out.[END]
When the thread queue is surrendered.[END]
When the thread queue enqueue operation timed out.[END]
When the thread queue enqueue operation timed out.[END]
When the thread queue enqueue operation timed out.[END]
When the thread queue enqueue operation timed out.[END]
The runtime of interface functions shall be measured.[END]
While the execution environment is below environments, while the barrier is an automaticrelease barrier, while the measurement sample is the runtime of exactly one successful callto rtems_barrier_wait which automatically releases the barrier, when exactly 100 samples arecollected, the below limit kinds shall be below limit conditions.[END]
Let U and V be two tasks with distinct home schedulers. Let Bbe a time point measured byU right before a call to rtems_barrier_wait which automaticall releases the barrier. Let Ebea time point measured by V right after a call to rtems_barrier_wait returns successfully dueto the rtems_barrier_wait call associated with B. While the execution environment is belowenvironments, while the barrier is an automatic release barrier, while the measurement sampleisE−B, when exactly 100 samples are collected, the below limit kinds shall be below limitconditions.[END]
While the execution environment is below environments, while the barrier is a manual re-lease barrier, while the measurement sample is the runtime of exactly one successful call tortems_barrier_release which does not preempt the caller, when exactly 100 samples are col-lected, the below limit kinds shall be below limit conditions.[END]
Let U and V be two tasks with the same home scheduler. Let Bbe a time point measuredby U right before a call to rtems_barrier_release which preempts the caller. Let Ebe a timepoint measured by V right after a call to rtems_barrier_wait returns successfully due to thertems_barrier_release call associated with B.While the execution environment is below environments, while the barrier is a manual releasebarrier, while the measurement sample is E−B, when exactly 100 samples are collected, thebelow limit kinds shall be below limit conditions.[END]
The runtime of @ref Real-Time Executive for Multiprocessor SystemsApplication Programming InterfaceClassicBarrier directives shall be measured.[END]
Let U be an interrupt service and V be a task which both execute on the same processor. Let Bbe a time point measured by U right before a call to rtems_event_send which unblocks task Vwhich preempts the executing task. Let Ebe a time point measured by V right after the ﬁrstcontext switch after B.While the execution environment is below environments, while task V waits for events, whilethe measurement sample is E−B, when exactly 100 samples are collected, the below limitkinds shall be below limit conditions.[END]
While the execution environment is below environments, while a task waits for events, while themeasurement sample is the runtime of exactly one successful call to rtems_event_send whichdoes satisfy the event condition of the waiting task which does not preempt the caller, whenexactly 100 samples are collected, the below limit kinds shall be below limit conditions.[END]
Let U and V be two tasks with distinct home schedulers. Let Bbe a time point measured byU right before a call to rtems_event_send which does satisfy the event condition of the waitingtask V which is scheduled on another processor. Let Ebe a time point measured by V right afterthe ﬁrst context switch after B.While the execution environment is below environments, while the task V waits for events,while the measurement sample is E−B, when exactly 100 samples are collected, the belowlimit kinds shall be below limit conditions.[END]
While the execution environment is below environments, while a task waits for events, while themeasurement sample is the runtime of exactly one successful call to rtems_event_send whichdoes not satisfy the event condition of the waiting task, when exactly 100 samples are collected,the below limit kinds shall be below limit conditions.[END]
Let U and V be two tasks with the same home scheduler. Let Bbe a time point measured byU right before a call to rtems_event_send which does satisfy the event condition of the waitingtask V which does preempt the caller. Let Ebe a time point measured by V right after the ﬁrstcontext switch after B.While the execution environment is below environments, while the task V waits for events,while the measurement sample is E−B, when exactly 100 samples are collected, the belowlimit kinds shall be below limit conditions.[END]
The runtime of @ref Real-Time Executive for Multiprocessor SystemsApplication Programming InterfaceClassicEvent directives shall be measured.[END]
While the execution environment is below environments, while a message queue isempty , while the measurement sample is the runtime of exactly one unsatisﬁed call tortems_message_queue_send, when exactly 100 samples are collected, the below limit kindsshall be below limit conditions.[END]
Let U and V be two tasks with the same home scheduler. Let Bbe a time point measured byU right before a call to rtems_message_queue_receive which blocks on the message queue withno timeout. Let Ebe a time point measured by V right after the ﬁrst context switch after B.While the execution environment is below environments, while a message queue is empty , whilethe measurement sample is E−B, when exactly 100 samples are collected, the below limit kindsshall be below limit conditions.[END]
Let U and V be two tasks with the same home scheduler. Let Bbe a time point measured by Uright before a call to rtems_message_queue_receive which blocks on the message queue with atimeout. Let Ebe a time point measured by V right after the ﬁrst context switch after B.While the execution environment is below environments, while a message queue is empty , whilethe measurement sample is E−B, when exactly 100 samples are collected, the below limit kindsshall be below limit conditions.[END]
The runtime of @ref Real-Time Executive for Multiprocessor SystemsApplication Programming InterfaceClassicMessage directives shall be measured.[END]
While the execution environment is below environments, while a message queue is empty , whileno task waits on the message queue, while the measurement sample is the runtime of exactlyone successful call to rtems_message_queue_send, when exactly 100 samples are collected, thebelow limit kinds shall be below limit conditions.[END]
While the execution environment is below environments, while a message queue is empty , whileexactly one task waits on the message queue, while the measurement sample is the runtime ofexactly one successful call to rtems_message_queue_send which does not preempt the caller,when exactly 100 samples are collected, the below limit kinds shall be below limit conditions.[END]
Let U and V be two tasks with distinct home schedulers. Let Bbe a time point measured byU right before a call to rtems_message_queue_send which unblocks the waiting task V whichis scheduled on another processor. Let Ebe a time point measured by V right after the ﬁrstcontext switch after B.While the execution environment is below environments, while a message queue is empty , whileonly task V waits on the message queue, while the measurement sample is E−B, when exactly100 samples are collected, the below limit kinds shall be below limit conditions.[END]
Let U and V be two tasks with the same home scheduler. Let Bbe a time point measured by Uright before a call to rtems_message_queue_send which unblocks the waiting task V which doespreempt the caller. Let Ebe a time point measured by V right after the ﬁrst context switch afterB.While the execution environment is below environments, while a message queue is empty , whileonly task V waits on the message queue, while the measurement sample is E−B, when exactly100 samples are collected, the below limit kinds shall be below limit conditions.[END]
While the execution environment is below environments, while a partition has exactly 100free buffers, while the measurement sample is the runtime of exactly one successful call tortems_partition_get_buffer, when exactly 100 samples are collected, the below limit kinds shallbe below limit conditions.[END]
While the execution environment is below environments, while a partition has no freebuffers, while the measurement sample is the runtime of exactly one unsatisiﬁed call tortems_partition_get_buffer, when exactly 100 samples are collected, the below limit kinds shallbe below limit conditions.[END]
While the execution environment is below environments, while a partition has exactly 100minus one free buffers, while the measurement sample is the runtime of exactly one successfulcall to rtems_partition_return_buffer, when exactly 100 samples are collected, the below limitkinds shall be below limit conditions.[END]
The runtime of @ref Real-Time Executive for Multiprocessor SystemsApplication Programming InterfaceClassicPart directives shall be measured.[END]
The runtime of the @ref Real-Time Executive for Multiprocessor SystemsApplication Programming InterfaceClassic directives shall be measured.[END]
While the execution environment is below environments, while the semaphore is a priorityinheritance mutex, while the measurement sample is the runtime of exactly one successful callto rtems_semaphore_obtain which immediately obtains the mutex, when exactly 100 samplesare collected, the below limit kinds shall be below limit conditions.[END]
While the execution environment is below environments, while the semaphore is a priorityinheritance mutex, while the measurement sample is the runtime of exactly one successful callto rtems_semaphore_release which does not unblock a waiting task, when exactly 100 samplesare collected, the below limit kinds shall be below limit conditions.[END]
While the execution environment is below environments, while the semaphore is a priorityinheritance mutex, while the measurement sample is the runtime of exactly one successfulcall to rtems_semaphore_release which does unblock exactly one waiting task which does notpreempt the caller, when exactly 100 samples are collected, the below limit kinds shall be belowlimit conditions.[END]
Let U and V be two tasks with distinct home schedulers. Let Bbe a time point measured byU right before a call to rtems_semaphore_release which unblocks task V which is scheduled onanother processor. Let Ebe a time point measured by V right after the ﬁrst context switch afterB.While the execution environment is below environments, while the semaphore is a priorityinheritance mutex, while exactly task V waits on the mutex, while the measurement sampleisE−B, when exactly 100 samples are collected, the below limit kinds shall be below limitconditions.[END]
Let U and V be two tasks with the same home scheduler. Let Bbe a time point measured by Uright before a call to rtems_semaphore_release which unblocks task V which does preempt thecaller. Let Ebe a time point measured by V right after the ﬁrst context switch after B.While the execution environment is below environments, while the semaphore is a priorityinheritance mutex, while exactly task V waits for the mutex, while the measurement sampleisE−B, when exactly 100 samples are collected, the below limit kinds shall be below limitconditions.[END]
While the execution environment is below environments, while the semaphore is a priority in-heritance mutex, while the measurement sample is the runtime of exactly one unsatisﬁed call tortems_semaphore_obtain which immediately returns, when exactly 100 samples are collected,the below limit kinds shall be below limit conditions.[END]
Let U and V be two tasks with the same home scheduler. Let Bbe a time point measured by Uright before a call to rtems_semaphore_obtain which blocks on the mutex with no timeout. LetEbe a time point measured by V right after the ﬁrst context switch after B.While the execution environment is below environments, while the semaphore is a priorityinheritance mutex, while the measurement sample is E−B, when exactly 100 samples arecollected, the below limit kinds shall be below limit conditions.[END]
Let U and V be two tasks with the same home scheduler. Let Bbe a time point measured by Uright before a call to rtems_semaphore_obtain which blocks on the mutex with a timeout. LetEbe a time point measured by V right after the ﬁrst context switch after B.While the execution environment is below environments, while the semaphore is a priorityinheritance mutex, while the measurement sample is E−B, when exactly 100 samples arecollected, the below limit kinds shall be below limit conditions.[END]
The runtime of @ref Real-Time Executive for Multiprocessor SystemsApplication Programming InterfaceClassicSem directives shall be measured.[END]
While the execution environment is below environments, while the measurement sample is theruntime of exactly one successful call to rtems_task_construct, when exactly 100 samples arecollected, the below limit kinds shall be below limit conditions.[END]
While the execution environment is below environments, while the measurement sample is theruntime of exactly one successful call to rtems_task_restart which does not preempt the caller,when exactly 100 samples are collected, the below limit kinds shall be below limit conditions.[END]
Let U and V be two tasks with the same home scheduler. Let Bbe a time point measured by Uright before a call to rtems_task_restart which starts task V which preempts the caller. Let Ebea time point measured by V right after the ﬁrst context switch after B.While the execution environment is below environments, while the measurement sample isE−B, the below limit kinds shall be below limit conditions.[END]
Let B be a time point measured by a task right before a call to rtems_task_restart which restartsthe caller. Let Ebe a time point measured by V right after the ﬁrst context switch after B.While the execution environment is below environments, while the measurement sample isE−B, the below limit kinds shall be below limit conditions.[END]
The runtime of @ref Real-Time Executive for Multiprocessor SystemsApplication Programming InterfaceClassicTasks directives shall be measured.[END]
While the execution environment is below environments, while the measurement sample is theruntime of exactly one successful call to rtems_task_set_scheduler which changes the schedulerof the caller, when exactly 100 samples are collected, the below limit kinds shall be below limitconditions.[END]
While the execution environment is below environments, while the measurement sample is theruntime of exactly one successful call to rtems_task_set_scheduler which does not change thescheduler or priority , when exactly 100 samples are collected, the below limit kinds shall bebelow limit conditions.[END]
While the execution environment is below environments, while the measurement sample is theruntime of exactly one successful call to rtems_task_set_scheduler which moves the task to thehome scheduler of the caller which does not preempt the caller, when exactly 100 samples arecollected, the below limit kinds shall be below limit conditions.[END]
Let U and V be two tasks with the distinct home schedulers. Let Bbe a time point measured byU right before a call to rtems_task_set_scheduler which moves task V to the home scheduler ofU which preempts the caller. Let Ebe a time point measured by V right after the ﬁrst contextswitch after B.While the execution environment is below environments, while the measurement sample isE−B, when exactly 100 samples are collected, the below limit kinds shall be below limitconditions.[END]
While the execution environment is below environments, while the measurement sample is theruntime of exactly one successful call to rtems_task_start which does not preempt the caller,when exactly 100 samples are collected, the below limit kinds shall be below limit conditions.[END]
Let U and V be two tasks with the same home scheduler. Let Bbe a time point measured by Uright before a call to rtems_task_start which starts task V which preempts the caller. Let Ebe atime point measured by V right after the ﬁrst context switch after B.While the execution environment is below environments, while the measurement sample isE−B, when exactly 100 samples are collected, the below limit kinds shall be below limitconditions.[END]
The Application Programming Interface shall contain the application conﬁguration interface.[END]
The implementation software architecture component have a component containing the ap-plication conﬁguration implementation.[END]
The BSPs shall be a software architecture component containing the implementation speciﬁcto targets and devices.[END]
The shared BSP interrupt support shall be a component containing functions used to imple-ment a Clock Driver.[END]
The fatal BSP support shall be a component containing functions used to indicate target-speciﬁc fatal errors.[END]
The shared BSP interrupt support shall be a component containing functions used to manageand process interrupts.[END]
The shared BSP support shall be a component containing functions used by multiple targets.[END]
The shared BSP startup support shall be a component containing functions used to initializethe system.[END]
The BSP component shall have a component containing the SPARC BSPs.[END]
The SPARC BSP component shall have a component containing the LEON3 compatible BSPs.[END]
The software product shall use the deﬁne SPARC_LEON3FT_B2BST_NOP in assembler languagesource code to insert nopinstructions required by the errata workaround.[END]
The software product shall take the errata 1 (FTAHBRAM: On-chip Memory not cacheable)into account.[END]
The software product shall take the errata 2 (CAN OC: interrupt can be cleared before read)into account.[END]
The software product shall take the errata 3 (GRSPW2: interrupt can be lost) into account.[END]
The software product shall take the errata 4 (GRSPW2: CRC calculation partially incorrect)into account.[END]
The software product shall take the errata 5 (SPICTRL: transfers in progress bit not cleared)into account.[END]
The software product shall take the errata 6 (SPICTRL: back-to-back transfers) into account.[END]
The software product shall take the errata 7 (FTMCTLR: EDAC usage with 8-bit wide mem-ory) into account.[END]
The software product shall take the errata 8 (LEON3FT Cache Controller: Incorrect Bus Ac-cess After Power-Down) into account.[END]
The software product shall take the errata 9 (Failing SDRAM Access After Uncorrectable EDACError) into account.[END]
The software product shall take the errata 10 (MIL-STD-1553B core duplicate interrupt as-sertion) into account.[END]
The software product shall take the errata 11 (Technical Note on LEON SRMMU Behaviour)into account.[END]
The software product shall take the errata 12 (Technical Note on GRETH Ethernet ControllerBehaviour) into account.[END]
The software product shall take the errata 13 (Technical Note on Stale Cache Entry AfterStore with Data Tag Parity Error) into account.[END]
The software product shall take the errata 14 (Never disable the TLB when the MMU isenabled) into account.[END]
The software product shall take the errata 15 (Technical Note on LEON3/FT AHB Lock Re-lease During Atomic Operation) into account.[END]
The software product shall take the errata 16 (Technical Note on GR712RC Incorrect Annu-lation of Floating-point Operation on) into account.[END]
The software product shall take the errata 17 (Technical Note on GRFPU Floating-point con-troller: Missing FDIV/FSQRT Result) into account.[END]
The software product shall take the errata 18 (Don’t break into debug mode on RETT instruc-tions) into account.[END]
The software product shall take the errata 19 (Stores to ASI 0x1C may update data cache)into account.[END]
The software product shall take the errata 20 (Technical Note on LEON3FT RETT RestartErrata) into account.[END]
The software product shall be compiled using the -mfix-gr712rc compiler option.[END]
The software product shall provide assembler language macros to help implementingworkarounds for the errata.[END]
The super core shall have a component containing the futex implementation those interfacesare deﬁned by Newlib.[END]
The super core shall have a component containing the system lock mutex implementationthose interfaces are deﬁned by Newlib.[END]
The software product shall have software architecture components containing the devicedrivers.[END]
The interfaces used or provided by the system shall be a contained in interface domains.[END]
The software product shall take target errata into account.[END]
If the system shall be implemented using ﬁne grained locking at the lowest level.[END]
The software product shall have software architecture components containing the implemen-tation.[END]
The software product shall be a real-time operating system.[END]
The system shall have a procedure to terminate the system.[END]
The validation and unit tests shall be a contained in test suites.[END]
The system shall document usage constraints of interfaces.[END]
The software architecture shall have a component containing the attribute support implemen-tation.[END]
The software architecture shall have a component containing the Barrier Manager implemen-tation.[END]
The software architecture shall have a component containing the Clock Manager implemen-tation.[END]
The software architecture shall have a component containing the Event Manager implemen-tation.[END]
The software architecture shall have a component containing the Message Manager imple-mentation.[END]
The software architecture shall have a component containing the Partition Manager imple-mentation.[END]
The software architecture shall have a component containing the Rate Monotonic Managerimplementation.[END]
The software architecture shall have a component containing the Classic Application Programming Interface implementation.[END]
The software architecture shall have a component containing the Scheduler Manager imple-mentation.[END]
The software architecture shall have a component containing the Semaphore Manager imple-mentation.[END]
The software architecture shall have a component containing the Signal Manager implemen-tation.[END]
The software architecture shall have a component containing the Task Manager implementa-tion.[END]
The software architecture shall have a component containing the Timer Manager implemen-tation.[END]
The software architecture shall have a component containing the User Extensions Managerimplementation.[END]
The super core shall have a component containing the implementation speciﬁc to the targetarchitecture and target.[END]
The super core shall be a software architecture component containing the implementationused by multiple Application Programming Interfaces.[END]
The super core shall have a component containing the system termination handling.[END]
The super core shall have a component containing the mutual exclusion object implementa-tion.[END]
The super core shall have a component containing the object services implementation.[END]
The super core shall have a component containing the scheduler implementations.[END]
The super core shall have a component containing the Earliest Deadline First Symmetric Multiprocessing /glossary/scheduler imple-mentation.[END]
The super core shall have a component containing the Symmetric Multiprocessing /glossary/scheduler implementa-tions.[END]
The super core shall have a component containing the semaphore object implementation.[END]
The super core shall have a component containing the Symmetric Multiprocessing-speciﬁc implementation.[END]
The super core shall have a component containing the thread implementation.[END]
Pinning of threads to a processor shall be supported.[END]
The timecounter component shall provide the CLOCK_MONOTONIC.[END]
The timecounter component shall provide the CLOCK_REALTIME.[END]
The timecounter component shall implement directives to get time values in the highest res-olution available to the system.[END]
The timecounter component shall implement directives to get time values in a coarse resolu-tion.[END]
The directives to get time values shall use a sequence lock to synchronize the reader withexactly one writer.[END]
The super core shall have a component containing the clock implementation.[END]
The timecounter component shall implement a directive to install a timecounter.[END]
The clock implementation shall optionally use a handler to do time adjustments and secondupdates through a NTP service.[END]
The clock implementation shall provide a simple timecounter tick service for timecounterdevices with a period equal to the clock tick interval.[END]
The super core shall have a component containing the thread queue implementation.[END]
The thread queue operations shall support deadlock detection.[END]
The state of each thread queue object shall be protected by an object-speciﬁc lock.[END]
The system shall provide a benchmark program to show the static memory us-age of a basic application conﬁguration with the clock driver enabled (CONFIG-URE_APPLICATION_NEEDS_CLOCK_DRIVER).[END]
The system shall provide benchmark programs to show the static memory usage of features.[END]
The system shall provide a benchmark program to show the static memory usage of a basicapplication conﬁguration with CONFIGURE_MAXIMUM_BARRIERS deﬁned to one and callsto rtems_barrier_create, rtems_barrier_wait, and rtems_barrier_release.[END]
The system shall provide a benchmark program to show the static memory usage of a basic ap-plication conﬁguration with CONFIGURE_MAXIMUM_BARRIERS deﬁned to one and calls tortems_barrier_create, rtems_barrier_wait, rtems_barrier_release, and rtems_barrier_delete.[END]
The system shall provide a benchmark program to show the static memory usage of a basicapplication conﬁguration with a call to rtems_clock_get_uptime.[END]
The system shall provide a benchmark program to show the static memory usage of a basicapplication conﬁguration with a call to rtems_clock_set.[END]
The system shall provide a benchmark program to show the static memory usage of a basicapplication conﬁguration with calls to rtems_clock_set and rtems_clock_get_tod.[END]
The system shall provide a benchmark program to show the static memory usage of a basicapplication conﬁguration with calls to rtems_event_send and rtems_event_receive.[END]
The system shall provide a benchmark program to show the static memory usage of a basicapplication conﬁguration with a call to rtems_fatal.[END]
The system shall provide a benchmark program to show the static memory us-age of a basic application conﬁguration with calls to rtems_message_queue_construct,rtems_message_queue_broadcast, and rtems_message_queue_receive.[END]
The system shall provide a benchmark program to show the static memory us-age of a basic application conﬁguration with calls to rtems_message_queue_construct,rtems_message_queue_send, and rtems_message_queue_receive.[END]
The system shall provide a benchmark program to show the static memory usageof a basic application conﬁguration with calls to rtems_message_queue_construct,rtems_message_queue_send, rtems_message_queue_receive, andrtems_message_queue_delete.[END]
The system shall provide a benchmark program to show the static memory us-age of a basic application conﬁguration with calls to rtems_message_queue_construct,rtems_message_queue_urgent, and rtems_message_queue_receive.[END]
The system shall provide a benchmark program to show the static memory usage of a basic ap-plication conﬁguration with CONFIGURE_MAXIMUM_PARTITIONS deﬁned to one and callsto rtems_partition_create, rtems_partition_get_buffer, and rtems_partition_return_buffer.[END]
The system shall provide a benchmark program to show the static memory usage of a ba-sic application conﬁguration with CONFIGURE_MAXIMUM_PARTITIONS deﬁned to one andcalls to rtems_partition_create, rtems_partition_get_buffer, rtems_partition_return_buffer,and rtems_partition_delete.[END]
The system shall provide a benchmark program to show the static memory usage of a basicapplication conﬁguration with CONFIGURE_MAXIMUM_PERIODS deﬁned to one and callsto rtems_rate_monotonic_create and rtems_rate_monotonic_period.[END]
The system shall provide a benchmark program to show the static memory us-age of a basic application conﬁguration with CONFIGURE_MAXIMUM_PERIODS deﬁnedto one and calls to rtems_rate_monotonic_create, rtems_rate_monotonic_period, andrtems_rate_monotonic_delete.[END]
The system shall provide a benchmark program to show the static memory usage of a basicapplication conﬁguration.[END]
The system shall provide a benchmark program to show the static memory usage of a basicapplication conﬁguration with CONFIGURE_MAXIMUM_PROCESSORS deﬁned to one usingthe Symmetric Multiprocessing Earliest Deadline First scheduler (CONFIGURE_SCHEDULER_Earliest Deadline First_Symmetric Multiprocessing).[END]
The system shall provide a benchmark program to show the static memory usage of a basicapplication conﬁguration with CONFIGURE_MAXIMUM_PROCESSORS deﬁned to two usingthe global Symmetric Multiprocessing Earliest Deadline First scheduler (CONFIGURE_SCHEDULER_Earliest Deadline First_Symmetric Multiprocessing).[END]
The system shall provide a benchmark program to show the static memory usage of a basicapplication conﬁguration with CONFIGURE_MAXIMUM_PROCESSORS deﬁned to four usingthe global Symmetric Multiprocessing Earliest Deadline First scheduler (CONFIGURE_SCHEDULER_Earliest Deadline First_Symmetric Multiprocessing).[END]
The system shall provide a benchmark program to show the static memory usageof a basic application conﬁguration with CONFIGURE_MAXIMUM_PROCESSORS de-ﬁned to two using one Symmetric Multiprocessing Earliest Deadline First scheduler for each conﬁgured processor (CONFIG-URE_SCHEDULER_Earliest Deadline First_Symmetric Multiprocessing).[END]
The system shall provide a benchmark program to show the static memory usageof a basic application conﬁguration with CONFIGURE_MAXIMUM_PROCESSORS de-ﬁned to four using one Symmetric Multiprocessing Earliest Deadline First scheduler for each conﬁgured processor (CONFIG-URE_SCHEDULER_Earliest Deadline First_Symmetric Multiprocessing).[END]
The system shall provide a benchmark program to show the static memory usage of a basicapplication conﬁguration with a call to rtems_scheduler_add_processor.[END]
The system shall provide a benchmark program to show the static memory usage of a basicapplication conﬁguration with a call to rtems_scheduler_remove_processor.[END]
The system shall provide a benchmark program to show the static memory usage of a basicapplication conﬁguration with CONFIGURE_MAXIMUM_SEMAPHORES deﬁned to one andcalls to rtems_semaphore_create, rtems_semaphore_obtain, and rtems_semaphore_release.[END]
The system shall provide a benchmark program to show the static memory usage of a basicapplication conﬁguration with CONFIGURE_MAXIMUM_SEMAPHORES deﬁned to one andcalls to rtems_semaphore_create, rtems_semaphore_obtain, rtems_semaphore_release, andrtems_semaphore_delete.[END]
The system shall provide a benchmark program to show the static memory usage of a basicapplication conﬁguration with calls to rtems_signal_catch and rtems_signal_send.[END]
The system shall provide a benchmark program to show the static memory usage of a basicapplication conﬁguration with a call to rtems_task_delete.[END]
The system shall provide a benchmark program to show the static memory usage of a basicapplication conﬁguration with a call to rtems_task_exit.[END]
The system shall provide a benchmark program to show the static memory usage of a basicapplication conﬁguration with a call to rtems_task_get_afﬁnity .[END]
The system shall provide a benchmark program to show the static memory usage of a basicapplication conﬁguration with a call to rtems_task_get_priority .[END]
The system shall provide a benchmark program to show the static memory usage of a basicapplication conﬁguration with a call to rtems_task_get_scheduler.[END]
The system shall provide a benchmark program to show the static memory usage of a basicapplication conﬁguration with a call to rtems_task_mode.[END]
The system shall provide a benchmark program to show the static memory usage of a basicapplication conﬁguration with a call to rtems_task_restart.[END]
The system shall provide a benchmark program to show the static memory usage of a basicapplication conﬁguration with a call to rtems_task_set_afﬁnity .[END]
The system shall provide a benchmark program to show the static memory usage of a basicapplication conﬁguration with a call to rtems_task_set_priority .[END]
The system shall provide a benchmark program to show the static memory usage of a basicapplication conﬁguration with a call to rtems_task_set_scheduler.[END]
The system shall provide a benchmark program to show the static memory usage of a basicapplication conﬁguration with calls to rtems_task_suspend and rtems_task_resume.[END]
The system shall provide a benchmark program to show the static memory usage of a basicapplication conﬁguration with a call to rtems_task_wake_after.[END]
The system shall provide a benchmark program to show the static memory usage of a basicapplication conﬁguration with a call to rtems_task_wake_when.[END]
The system shall provide a benchmark program to show the static memory usage of a basicapplication conﬁguration with calls to rtems_timer_create and rtems_timer_ﬁre_after.[END]
The system shall provide a benchmark program to show the static memory usage of a basicapplication conﬁguration with calls to rtems_timer_create and rtems_timer_cancel.[END]
The system shall provide a benchmark program to show the static memory usage of a basicapplication conﬁguration with calls to rtems_timer_create and rtems_timer_delete.[END]
The system shall provide a benchmark program to show the static memory usage of a basicapplication conﬁguration with calls to rtems_timer_create and rtems_timer_reset.[END]
The system shall provide a benchmark program to show the static memory usage of a basicapplication conﬁguration with calls to rtems_timer_create and rtems_timer_server_ﬁre_after.[END]
The system shall provide a benchmark program to show the static memory usage of a basicapplication conﬁguration with a call to rtems_timer_initiate_server.[END]
The system shall provide a benchmark program to show the static memory usage of a basic ap-plication conﬁguration with calls to rtems_timer_create and rtems_timer_server_ﬁre_when.[END]
The system shall provide a benchmark program to show the static memory usage of a basicapplication conﬁguration with calls to rtems_timer_create and rtems_timer_ﬁre_when.[END]
The system shall provide a benchmark program to show the static memory usage of a basicapplication conﬁguration with CONFIGURE_MAXIMUM_USER_EXTENSIONS deﬁned to oneand a call to rtems_extension_create.[END]
The system shall provide a benchmark program to show the static memory usage of a basicapplication conﬁguration with CONFIGURE_MAXIMUM_USER_EXTENSIONS deﬁned to oneand calls to rtems_extension_create and rtems_extension_delete.[END]
